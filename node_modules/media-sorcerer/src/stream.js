import eventManager from 'eventmanager';
import Fetcher from './fetcher';

class Stream {

    // A string (url) or object (url + byteRange) is valid
    static isValidSegmentUrl(segment) {
        if (typeof segment === 'string') {
            return true;
        }

        if (typeof segment.url === 'string' && typeof segment.byteRange === 'string') {
            return true;
        }

        return false;
    }

    /**
     * The Stream object is a representation of a specific quality of audio or video.
     *
     * @param {UInt8Array|String|Object} initSegment A URL or ArrayBuffer representing the init segment for this stream.
     * @param {String} [codec] The codec string originally passed in when creating the stream with MediaSorcerer.addStream.
     * @param {Fetcher} [fetcher] A optional reference to a Fetcher instance.
     */
    constructor(initSegment, codec = '', fetcher = new Fetcher()) {
        eventManager(this);

        this._readyToAppend = [];
        this._initSegment = null;
        this._index = NaN;
        this._codec = codec;
        this._fetcher = fetcher;
        this._fetcher.start();

        this._bufferData = new WeakMap();
        this._segmentToId = {};

        this._getInitSegmentPromise = new Promise((resolve, reject) => {
            if (Stream.isValidSegmentUrl(initSegment)) {
                this._fetcher.add({
                    url: initSegment.url || initSegment,
                    byteRange: initSegment.byteRange,
                    id: null,
                    stream: this
                }, (buffer) => {
                    this._initSegment = buffer;
                    resolve(buffer);
                });
                return;
            }

            this._initSegment = initSegment;
            resolve(initSegment);
        });
    }

    get codec() {
        return this._codec;
    }

    set codec(value) {
        this._codec = value;
    }

    get index() {
        return this._index;
    }

    set index(value) {
        this._index = value;
    }

    get pendingFetches() {
        return this._fetcher.pendingFetches;
    }

    getIdForSegment(segment) {
        if (Stream.isValidSegmentUrl(segment)) {
            return this._segmentToId[segment];
        }

        return this._bufferData.get(segment).id;
    }

    isFinal(segment) {
        return this._bufferData.get(segment).final;
    }

    /**
     * Adds a segment to a stream.
     *
     * @param {UInt8Array|String|Object} segment - Actual buffer data (initSegment), segment url, or {url, byteRange}
     * @param {Object} [options.identifier] - The stream indentifier object
     * @param {Boolean} [options.isFinalSegment] - Whether or not this is the final segment
     * @param {Boolean} [options.loadOnly] - If the segment should be preloaded
     * @param {Number} [options.priority] - The segment priority. lower number means it will end up earlier in
     *                                     the queue. So 0 means it will be placed at the beginning.
     * @param {Boolean} [options.includeWithBandwidthChecks] - If this download of this segment should be included in
     *                                                        bandwidth checks.
     * @return {Void}
     */
    addSegment(segment, { identifier = null, isFinalSegment = false, loadOnly = false, priority = 0, includeWithBandwidthChecks = true } = {}) {

        return new Promise((resolve, reject) => {
            if (Stream.isValidSegmentUrl(segment)) {
                this._segmentToId[segment] = identifier || segment;

                this.fire('queued', this.getIdForSegment(segment));

                this._fetcher.add({
                    url: segment.url || segment,
                    byteRange: segment.byteRange,
                    id: this.getIdForSegment(segment),
                    stream: this,
                    includeWithBandwidthChecks,
                    priority
                }, (buffer) => {
                    this._bufferData.set(buffer, {
                        id: identifier || segment,
                        final: isFinalSegment
                    });

                    this._readyToAppend.push(buffer);

                    this.fire('bufferqueueadd', this.getIdForSegment(segment));

                    if (!loadOnly) {
                        this.fire('segmentadd');
                    }

                    resolve();
                });

                return;
            }

            this._bufferData.set(segment, {
                id: identifier,
                final: isFinalSegment
            });

            this._readyToAppend.push(segment);
            this.fire('bufferqueueadd', identifier);

            resolve();
        });
    }

    clear() {
        this._readyToAppend = [];
    }

    abort() {
        // This has to wait on the init segment to be ready because otherwise
        // if abort is called while the init segment is downloaded it will abort
        // the init segment request.
        this._getInitSegmentPromise.then(() => {
            this._fetcher.abort(this);
            return;
        }).catch((error) => {
            console.error(error);
        });
    }

    getNextSegment() {
        if (this._readyToAppend.length === 0) {
            return null;
        }

        return this._readyToAppend.shift();
    }

    getInitSegment() {
        return this._getInitSegmentPromise;
    }
}

export default Stream;
