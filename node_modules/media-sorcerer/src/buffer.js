import eventManager from 'eventmanager';

const segmentDuration = 6;

class Buffer {

    /**
     * The Buffer object is a wrapper around the native SourceBuffer object.
     * It queries streams to get what segments to append to the buffer and handles switching between streams.
     *
     * @param  {MediaSorcerer} sorcerer
     */
    constructor(sorcerer) {
        eventManager(this);

        this._sorcerer = sorcerer;
        this._sourceBuffer = null;
        this._activeStreamIndex = null;
        this._needsStreamSwitch = false;
        this._needInitSegment = true;
        this._lastAppended = null;
        this._toRemove = [];
        this._streams = [];
        this._quotaExceeded = false;
        this._quotaExceededTimer = null;
        this._appendingFinalSegment = false;
        this._finalSegmentTime = undefined;
        this._addingInitSegment = false;
        this._isFirstSegment = true;
        this._bufferState = {};

        this._sorcerer.on('durationset', this._onDurationSet.bind(this));
    }

    get streams() {
        return this._streams;
    }

    get activeStreamIndex() {
        return this._activeStreamIndex;
    }

    get sourceBuffer() {
        return this._sourceBuffer;
    }

    set sourceBuffer(sourceBuffer) {
        this._sourceBuffer = sourceBuffer;
        this._attachEvents();
        this.fire('sourcebufferattach');
    }

    ////////////////////
    // Public methods //
    ////////////////////

    /**
     * Adds a stream object to this buffer.
     *
     * @param {Stream} stream A Stream object.
     */
    addStream(stream) {
        stream.on('segmentadd', () => this._process());

        const index = this._streams.push(stream) - 1;
        stream.index = index;

        if (this._activeStreamIndex === null) {
            this._setActiveIndex(index);
            this._needsStreamSwitch = true;
        }
    }

    /**
     * Retrieves the index of the stream in the buffer at input time.
     *
     * @param {Number} time - The video time to retrieve buffer
     * @return {Number}
     */
    streamIndexAtTime(time) {
        // In Live, this is what the bufferState looks like
        // so we can get the active stream at the current time instead
        if (this._bufferState[undefined]) {
            return { stream: this.activeStreamIndex };
        }

        return this._bufferState[Math.floor(time / segmentDuration)];
    }

    /**
     * Switches the currently active stream to the specified stream or stream index.
     *
     * @param {Object} stream A Stream object or numeric index of which stream to switch to.
     * @param {Boolean} [abort] If the previous stream should be aborted.
     * @return {Promise} A Promise that will resolve when the first segment of the new stream has been appended to the buffer.
     */
    switchTo(stream, abort = true) {
        let index = stream;
        if (typeof stream === 'object') {
            index = stream.index;
        }

        let indexHasChanged = this._activeStreamIndex !== index;
        const shouldAbort = indexHasChanged;

        // An index is set up by default when the first stream has been added
        // and that becomes the active index. This means if we later decide to
        // switch to that index we need to make sure to still fire the
        // streamswitch event before playback begins.
        if (!indexHasChanged && this._needsStreamSwitch) {
            indexHasChanged = true;
        }

        if (indexHasChanged) {
            // Assuming we have gotten here that means we don't need to force
            // another streamswitch event in the future
            this._needsStreamSwitch = false;

            const previousStreamIndex = this._activeStreamIndex;
            const previousStream = this._streams[previousStreamIndex];

            if (previousStream && shouldAbort && abort) {
                previousStream.abort();
            }

            this._switchToIndex = index;
            this._setActiveIndex(index);
        }

        this._process();

        return new Promise((resolve) => {
            if (!indexHasChanged) {
                resolve();
                return;
            }

            this._resolveSwitchComplete = () => {
                if (this._switchToIndex !== index) {
                    return;
                }

                this._resolveSwitchComplete = null;
                resolve();
                this.fire('streamchange', index);
            };
        });
    }

    /**
     * Returns if the supplied time is within the source buffer.
     *
     * @param {Number} time - The time to lookup in seconds.
     * @return {Boolean}
     */
    isTimeInBuffer(time) {
        for (let i = 0; i < this.sourceBuffer.buffered.length; i++) {
            const bufferStart = this.sourceBuffer.buffered.start(i);
            const bufferEnd = this.sourceBuffer.buffered.end(i);

            if (bufferStart <= time && bufferEnd >= time) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns if the final segment has been appended for the purpose of firing
     * MediaSource.endOfStream().
     *
     * @return {Boolean}
     */
    hasAppendedFinalSegment() {
        if (this._finalSegmentTime === undefined) {
            return false;
        }

        return this.isTimeInBuffer(this._finalSegmentTime);
    }

    /**
     * Clears out all segments in the queue for all streams
     * belonging to this buffer.
     */
    clear() {
        this._streams.forEach((stream) => {
            stream.clear();
        });
    }

    /**
     * Removes the allocated buffer between two playback times.
     *
     * @param  {Number} startTime The video time in seconds to start removal.
     * @param  {Number} [endTime] The video time in seconds to end removal.
     * @return {Promise}
     */
    remove(startTime, endTime = this._sorcerer._mediaSource.duration) {
        return new Promise((resolve, reject) => {
            this._toRemove.push([startTime, endTime, resolve]);
            this._process();
        });
    }

    /////////////////////
    // Private methods //
    /////////////////////

    /**
     * Initializes the buffer tracking object.
     */
    _onDurationSet() {
        const duration = this._sorcerer._mediaSource.duration;
        let segments = Math.floor(duration / segmentDuration);
        segments += (segmentDuration % duration) > 1 ? 1 : 0;
        for (let i = 0; i < segments; i++) {
            this._bufferState[i] = {
                stream: null,
                segment: i,
                type: 'video'
            };
        }
    }

    _attachEvents() {
        this.bound = {
            handleUpdateEnd: this._handleUpdateEnd.bind(this)
        };

        this._sourceBuffer.addEventListener('updateend', this.bound.handleUpdateEnd);
        this._sorcerer.on('endofstream', () => {
            this._handleUpdateEnd();
        });

        this._sorcerer.on('ended', this.bound.handleEnded);
    }

    _handleUpdateEnd(e) {
        if (this._appendingFinalSegment) {
            this._finalSegmentTime = this._sourceBuffer.buffered.end(this._sourceBuffer.buffered.length - 1);
            this._sorcerer._fireStreamHasEnded();
            this._appendingFinalSegment = false;
        }

        if (this._lastAppended) {
            this.fire('appendbufferend', this._lastAppended);
            this._lastAppended = null;

            if (this._resolveSwitchComplete) {
                this._resolveSwitchComplete();
            }
        }
        this._process();
    }

    _removeEventListeners() {
        // It is possible for MediaSorcerer.destroy() to be called as a result
        // of failing to create sourceBuffers because the codec is not supported
        // by the browser. In that case a source buffer will never be added so
        // there won't be any bound events to actually remove since
        // _attachEvents was never actually called. This makes sure we have
        // bound events before trying to remove them.
        //
        // @see https://github.vimeows.com/player/player/issues/1744
        if (!this.bound) {
            return;
        }

        if (this._sourceBuffer) {
            this._sourceBuffer.removeEventListener('updateend', this.bound.handleUpdateEnd);
        }

        this._sorcerer.off('endofstream', this.bound.handleUpdateEnd);
        this._sorcerer.off('ended', this.bound.handleEnded);
    }

    _setActiveIndex(index) {
        // Anytime we switch streams, we need the init segment
        this._needInitSegment = true;
        this._activeStreamIndex = index;
        this._sorcerer._frameDropper.streamIndex = index;
    }

    /* eslint-disable complexity */
    _process() {
        const activeStream = this._streams[this._activeStreamIndex];

        if (!this._sourceBuffer) {
            this.on('sourcebufferattach', this._process);
            return;
        }

        if (!activeStream) {
            return;
        }

        // We can only append to the source buffer if the ready state is open
        // or ended, but not closed.
        //
        // The source will be reopened if it is in the ended state
        //
        // http://www.w3.org/TR/media-source/#widl-MediaSource-readyState
        // http://www.w3.org/TR/media-source/#sourcebuffer-prepare-append
        if (this._sorcerer._mediaSource.readyState === 'closed') {
            return;
        }

        const sourceBuffer = this._sourceBuffer;
        if (sourceBuffer.updating) {
            return;
        }

        if (this._toRemove.length) {
            const [startTime, endTime, resolve] = this._toRemove.shift();
            const self = this;
            sourceBuffer.addEventListener('updateend', function handleUpdateEnd(e) {
                sourceBuffer.removeEventListener('updateend', handleUpdateEnd);
                resolve();

                clearTimeout(self._quotaExceededTimer);
                self._quotaExceededTimer = setTimeout(() => {
                    self._quotaExceeded = false;
                    self._process();
                }, 5000);
            });

            const start = startTime;
            sourceBuffer.remove(start, endTime);
            return;
        }

        // If we are part of a quotaExceeded removal then we should not do
        // anything
        if (this._quotaExceeded) {
            return;
        }

        // init segment should always be appended before other segments
        if (this._addingInitSegment) {
            return;
        }

        if (this._needInitSegment) {
            this._addingInitSegment = true;
            activeStream.getInitSegment().then((buffer) => {
                // ignore init segments for updateend events
                this._lastAppended = null;
                sourceBuffer.appendBuffer(buffer);
                this._addingInitSegment = false;
                return buffer;
            }).catch((err) => {
                console.error(err);
                this._addingInitSegment = false;
            });
            this._needInitSegment = false;
            return;
        }

        const toAppend = activeStream.getNextSegment();
        // toAppend can be null when loading init segment and no other
        // segments have loaded yet
        if (toAppend === null) {
            return;
        }

        const identifier = activeStream.getIdForSegment(toAppend);
        const isFinalSegment = activeStream.isFinal(toAppend);

        if (isFinalSegment) {
            this._appendingFinalSegment = true;
        }

        this._lastAppended = identifier;
        this.fire('appendbufferstart', identifier);

        try {
            sourceBuffer.appendBuffer(toAppend);
            this._bufferState[identifier.segment] = identifier;

            if (this._isFirstSegment) {
                this._isFirstSegment = false;
                this.fire('initialbufferstart');
            }
        }
        catch (e) {
            if (e.name === 'QuotaExceededError') {
                this._quotaExceeded = true;
                console.warn('QuotaExceededError');

                // When you call remove on a SourceBuffer it has to be behind
                // the currentTime by a certain amount otherwise you could run
                // into issues where you end up removing the video in the buffer
                // at the currentTime since the browser may remove up until the
                // nearest keyframe to the endTime. Six seconds is an okay
                // threshold for now.
                const removalThreshold = 6;
                if (this._sorcerer._video.currentTime > removalThreshold) {
                    const startTime = 0;
                    const endTime = this._sorcerer._video.currentTime - removalThreshold;
                    console.log(`Removing buffer from ${startTime} to ${endTime}…`);
                    this._sorcerer.removeBuffer(startTime, endTime);
                }

                activeStream._readyToAppend.unshift(toAppend);
            }
        }
    }
    /* eslint-enable complexity */

}

export default Buffer;
