import Fetcher from './fetcher';
import Buffer from './buffer';
import Stream from './stream';
import FrameDropper from './framedropper';
import eventManager from 'eventmanager';

class MediaSorcerer {

    /**
     * Creates a new MediaSorcerer object.
     *
     * @param  {HTMLElement} video A reference to the video tag element on the page that you want to use MediaSource with.
     * @param  {Object} [options] Options for MediaSorcerer. Currently the only supported option is the video duration.
     */
    constructor(video, options = {}) {
        this._video = video;
        this._options = options;

        eventManager(this);

        // In Chrome there is an issue with floats where the duration may show
        // up as 186.773333333 and the currentTime at the end shows up as
        // 186.773333.
        //
        // There are also cases where the duration might be 16.766 and the
        // currentTime comes back as 16.765999
        //
        // In order to work around this we need to change the duration passed to
        // the media source object.
        //
        // Why we need to ceil this to the nearest hundred is beyond me.
        // Somehow by changing it, it causes Chrome to correctly map the
        // video.currentTime to the video.duration. Otherwise there are floating
        // point rounding errors.
        if (this._options.duration) {
            this._options.duration = Math.ceil(this._options.duration * 100) / 100;
        }

        this._bufferCount = 0;
        this._frameDropper = new FrameDropper(video);
        this._mediaSource = new MediaSource();
        this._fetcher = new Fetcher({ parallel: 1 });
        this._video.src = URL.createObjectURL(this._mediaSource);
        this._buffersForCodec = {};
        this._readyPromiseResolve = null;

        this._attachEvents();
    }

    /**
     * A reference to the actual MediaSource object being used for playback.
     *
     * @return {MediaSource}
     */
    get mediaSource() {
        return this._mediaSource;
    }

    /**
     * A shortcut for accessing Stream objects when there is a single (video) buffer.
     *
     * @return {Array|Buffer}
     */
    get streams() {
        if (this._bufferCount === 1) {
            return this.video.streams;
        }

        console.error('The streams property on MediaSorcerer only works with single streams');
        return false;
    }

    /**
     * A shortcut for accessing the currently active stream index when there is a single (video) buffer.
     *
     * @return {Number|Boolean}
     */
    get activeStreamIndex() {
        if (this._bufferCount === 1) {
            return this.video.activeStreamIndex;
        }

        console.error('The activeStreamIndex property on MediaSorcerer only works with single streams');
        return false;
    }

    /**
     * A reference to the video buffer object or false if there is no video buffer.
     *
     * @return {Buffer|Boolan}
     */
    get video() {
        if (this._buffersForCodec.video) {
            return this._buffersForCodec.video;
        }

        console.error('No video streams have been added to MediaSorcerer');
        return false;
    }

    /**
     * A reference to the audio buffer object or false if there is no audio buffer.
     *
     * @return {Buffer|Boolean}
     */
    get audio() {
        if (this._buffersForCodec.audio) {
            return this._buffersForCodec.audio;
        }

        console.error('No audio streams have been added to MediaSorcerer');
        return false;
    }

    ////////////////////
    // Public methods //
    ////////////////////

    /**
     * A shortcut for calling Buffer.switchTo when there is only a single (video) buffer
     *
     * @param  {Object} stream
     * @return {Boolean|Promise}
     */
    switchTo(stream) {
        if (this._bufferCount === 1) {
            return this.video.switchTo(stream);
        }

        console.error('The switch method on MediaSorcerer only works with single streams');
        return false;
    }

    /**
     * Gets the current download speed for the viewer in bps (bits per second).
     *
     * Available Options
     *   type {String} The way to calculate the speed (“average”, “median”, or “percentile”).
     *   howMany {Number} The number of recent speeds to include when doing the calculation.
     *   weights {Array} An array of weights to use to calculate a weighted average.
     *   percentile {Number} The percentile to use from 0 to 1 if you want a percentile speed.
     *
     * @param {Object} options An object containing options
     * @return {Number}
     */
    getCurrentSpeed({ type = 'average', howMany = 10, weights = [], percentile = null } = {}) {
        if (type === 'average') {
            return Fetcher.getAverageSpeed(howMany, weights);
        }

        if (type === 'median') {
            return Fetcher.getMedianSpeed(howMany);
        }

        return Fetcher.getPercentileSpeed(howMany, percentile);
    }

    /**
     * Returns the average segment download bitrate.
     *
     * @param  {Number} [time] - Time interval in milliseconds to look back on
     * @return {Number} The average segment download bitrate
     */
    getAverageDownloadBitrate(time = 1000) {
        return Fetcher.getAverageBitrate(time);
    }

    /**
     * Returns an array of (up to) the last 100 raw response speeds (in bits per second)
     * in case you want to use them in a way that getCurrentSpeed will provide.
     *
     * @return {Array}
     */
    getResponseSpeeds() {
        return Fetcher.getResponseSpeeds();
    }

    /**
     * Returns the failed segments array
     *
     * @return {Array}
     */
    getFailedSegments() {
        return Fetcher.getFailedSegments();
    }

    /**
     * Returns the successful segments array
     *
     * @return {Array}
     */
    getSuccessfulSegments() {
        return Fetcher.getSuccessfulSegments();
    }

    /**
     * Returns the rate of dropped frames over the last x number of seconds.
     *
     * @param  {Number} howMany Number of seconds to look at.
     * @param  {Number} [streamIndex] Which stream to check.
     * @param  {String} [type] How to calculate the number of dropped frames (“average”, or “median”).
     * @return {Number}
     */
    getDroppedFrameRate(howMany, streamIndex = this.activeStreamIndex, type = 'average') {
        return this._frameDropper.getDroppedFrameRate(howMany, streamIndex, type);
    }

    /**
     * Returns the total number of dropped frames throughout the entire playback session.
     *
     * @return {Number}
     */
    getDroppedFrameTotal() {
        return this._frameDropper.getDroppedFrameTotal();
    }

    /**
     * Clears out all buffers that are currently in the queue to be
     * appended across all buffers and streams.
     */
    clear() {
        for (const type in this._buffersForCodec) {
            this._buffersForCodec[type].clear();
        }
    }

    /**
     * Returns a stream object from a given video time.
     *
     * @param  {Number} time - The video time to lookup
     * @param  {String} type - The type of stream to reference ('audio' or 'video')
     * @return {Object}
     */
    streamIndexAtTime(time, type) {
        if (!this._buffersForCodec[type].streamIndexAtTime(time)) {
            return null;
        }

        return this._buffersForCodec[type].streamIndexAtTime(time).stream;
    }

    /**
     * Calls Buffer.remove on each Buffer object that has been created.
     *
     * @param  {Number} [startTime]
     * @param  {Number} [endTime]
     * @return {Promise}
     */
    removeBuffer(startTime = 0, endTime = this._video.duration) {
        if (startTime > endTime) {
            return Promise.resolve();
        }

        const promises = [];
        for (const type in this._buffersForCodec) {
            promises.push(this._buffersForCodec[type].remove(startTime, endTime));
        }

        return Promise.all(promises);
    }

    /**
     * Creates a new Stream object and adds it to the corresponding Buffer object.
     *
     * @param {String} codec The codec string corresponding to the stream you are creating.
     * @param {String} initSegment A URL or ArrayBuffer object representing the init segment for this stream.
     * @return {Object} The newly created stream object.
     */
    addStream(codec, initSegment) {
        const codecType = this._getCodecType(codec);
        if (!this._buffersForCodec[codecType]) {
            this._bufferCount += 1;
            const buffer = new Buffer(this, codecType);
            this._buffersForCodec[codecType] = buffer;

            this.readyPromise.then(() => {
                let sourceBuffer;
                try {
                    sourceBuffer = this._mediaSource.addSourceBuffer(codec);
                }
                catch (e) {

                    // if we have hit the maximum number then return the last
                    // used video source buffer
                    if (e.code === 22) {
                        sourceBuffer = this._buffersForCodec[codecType];
                    }
                    else {
                        console.error(e);
                        this.fire('srcnotsupported', e);
                        return;
                    }
                }

                // This prevents a segment from being able to be added beyond a
                // certian time.
                if (this._options.duration) {
                    sourceBuffer.appendWindowEnd = this._options.duration;
                }

                buffer.sourceBuffer = sourceBuffer;

                return;
            }).catch((error) => {
                console.error(error);
            });

            ['appendbufferstart', 'appendbufferend', 'streamchange', 'initialbufferstart'].forEach((evt) => {
                buffer.on(evt, (identifier) => {
                    this.fire(evt, identifier);
                });
            });
        }

        const stream = new Stream(initSegment, codec, this._fetcher);

        // Might not need 'queued' event soon since addSegment has been
        // promisified.
        ['queued', 'bufferqueueadd'].forEach((evt) => {
            stream.on(evt, (identifier) => {
                this.fire(evt, identifier);
            });
        });

        this._buffersForCodec[codecType].addStream(stream);

        return stream;
    }

    /**
     * Destroys the MediaSorcerer instance and removes all event listeners.
     */
    destroy() {
        this.clear();
        this._removeEventListeners();

        this._frameDropper.destroy();
        this._fetcher.abort();

        if (this._video.src) {
            URL.revokeObjectURL(this._video.src);
        }
    }

    /////////////////////
    // Private methods //
    /////////////////////

    _attachEvents() {
        this.bound = {
            handleSourceOpen: this._handleSourceOpen.bind(this)
        };

        this.readyPromise = new Promise((resolve, reject) => {
            this._readyPromiseResolve = resolve;
            this._mediaSource.addEventListener('sourceopen', this.bound.handleSourceOpen);
        });

        ['downloadstart', 'downloadend', 'downloadabort', 'downloaderror', 'progress'].forEach((event) => {
            this._fetcher.on(event, (...data) => {
                this.fire(event, ...data);
            });
        });
    }

    _sourceBuffersAreUpdating() {
        for (let i = 0; i < this._mediaSource.sourceBuffers.length; i++) {
            if (this._mediaSource.sourceBuffers[i].updating) {
                return true;
            }
        }

        return false;
    }

    _fireStreamHasEnded() {
        for (const type in this._buffersForCodec) {
            const buffer = this._buffersForCodec[type];
            if (!buffer.hasAppendedFinalSegment()) {
                return;
            }
        }

        // If the ready state is not open or there are source buffers updating
        // we cannot call endOfStream
        //
        // @see http://www.w3.org/TR/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error
        if (this._mediaSource.readyState !== 'open') {
            return;
        }

        if (this._sourceBuffersAreUpdating()) {
            return;
        }

        console.log('Firing MediaSource.endOfStream()');
        this._mediaSource.endOfStream();
        this.fire('endofstream');
    }

    _handleSourceOpen() {
        if (this._options.duration) {
            this._mediaSource.duration = this._options.duration;
            this.fire('durationset');
        }

        this._readyPromiseResolve();

        this._mediaSource.removeEventListener('sourceopen', this.bound.handleSourceOpen);
    }

    _removeEventListeners() {
        for (const type in this._buffersForCodec) {
            this._buffersForCodec[type]._removeEventListeners();
        }
    }

    _getCodecType(codec) {
        return codec.indexOf('audio') === 0 ? 'audio' : 'video';
    }
}

export default MediaSorcerer;
