{"version":3,"file":null,"sources":["../src/util.js","../node_modules/eventmanager/src/eventmanager.js","../src/fetcher.js","../src/buffer.js","../src/stream.js","../src/framedropper.js","../src/mediasorcerer.js"],"sourcesContent":["export function average(times, weights = []) {\n    // Prevent deviding by zero\n    if (times.length === 0) {\n        return 0;\n    }\n\n    let total = 0;\n    let length = 0;\n\n    for (let i = 0; i < times.length; i++) {\n        const weight = weights[i] || 1;\n        length += weight;\n        total += times[i] * weight;\n    }\n\n    return total / length;\n}\n\n// @see https://gist.github.com/IceCreamYou/6ffa1b18c4c8f6aeaad2\nexport function percentile(arr, p) {\n    arr.sort();\n\n    if (arr.length === 0) {\n        return 0;\n    }\n\n    if (p <= 0) {\n        return arr[0];\n    }\n\n    if (p >= 1) {\n        return arr[arr.length - 1];\n    }\n\n    const index = arr.length * p;\n    const lower = Math.floor(index);\n    const upper = lower + 1;\n    const weight = index % 1;\n\n    if (upper >= arr.length) {\n        return arr[lower];\n    }\n\n    return (arr[lower] * (1 - weight)) + (arr[upper] * weight);\n}\n\nexport function median(times) {\n    times.sort((a, b) => a - b);\n\n    const half = Math.floor(times.length / 2);\n\n    if (times.length % 2) {\n        return times[half];\n    }\n\n    return (times[half - 1] + times[half]) / 2.0;\n}\n\nexport function parseResponseHeaders(string) {\n    if (!string) {\n        return {};\n    }\n\n    return string.split('\\n').reduce((obj, header) => {\n        const colon = header.indexOf(':');\n        const key = header.substring(0, colon);\n        const value = header.substring(colon + 1);\n\n        if (typeof key !== 'undefined' && typeof value !== 'undefined') {\n            obj[key.trim().toLowerCase()] = value.trim();\n        }\n\n        return obj;\n    }, {});\n}\n","export default function eventManager(obj) {\n    obj = obj || {};\n    var events = {};\n\n    // Add a listener for an event\n    obj.on = function(eventName, handler) {\n        eventName = [].concat(eventName);\n\n        for (var i = 0, length = eventName.length; i < length; i++) {\n            var currentEvent = eventName[i];\n\n            if (!currentEvent) {\n                throw new Error('Tried to listen for an undefined event.');\n            }\n\n            if (!events[currentEvent]) {\n                events[currentEvent] = [];\n            }\n\n            events[currentEvent].push(handler);\n        }\n\n        return obj;\n    };\n\n    // Add a listener for an event that will run one time only\n    obj.once = function(eventName, handler) {\n        function wrappedHandler() {\n            handler.apply(obj.off(eventName, wrappedHandler), arguments);\n        }\n\n        // Store a reference to the original handler so we can remove it\n        // if you call off with that handler.\n        wrappedHandler.handler = handler;\n\n        return obj.on(eventName, wrappedHandler);\n    };\n\n    // Remove a listener from an event\n    obj.off = function(eventName, handler) {\n        eventName = [].concat(eventName);\n\n        for (var i = 0, length = eventName.length; i < length; i++) {\n            var currentEvent = eventName[i];\n\n            if (!currentEvent) {\n                throw new Error('Tried to remove an undefined event.');\n            }\n\n            if (currentEvent in events) {\n                var index = events[currentEvent].indexOf(handler);\n\n                // Loop through all the handlers to find the wrapper so we can remove it\n                // Not in there, return\n                if (index === -1) {\n                    for (var j = 0, jlength = events[currentEvent].length; j < jlength; j++) {\n                        if (events[currentEvent][j].handler === handler) {\n                            index = i;\n                            break;\n                        }\n                    }\n\n                    if (index === -1) {\n                        return obj;\n                    }\n                }\n\n                events[currentEvent].splice(index, 1);\n            }\n        }\n\n        return obj;\n    };\n\n    // Fire an event\n    obj.fire = function(eventName) {\n        if (!eventName) {\n            throw new Error('Tried to fire an undefined event.');\n        }\n\n        if (eventName in events) {\n\n            // Make a copy so that we will definitely loop through all,\n            // even if a handler is removed during the loop (by once, for example).\n            var eventsCopy = events[eventName].slice(0);\n\n            for (var i = 0, length = eventsCopy.length; i < length; i++) {\n                eventsCopy[i].apply(obj, eventsCopy.slice.call(arguments, 1));\n            }\n        }\n\n        return obj;\n    };\n\n    return obj;\n}\n","import { percentile, average, median, parseResponseHeaders } from './util';\nimport eventManager from 'eventmanager';\n\nconst responseSpeeds = [];\nconst failedSegments = [];\nconst successfulSegments = [];\n\n/**\n * progressSpeeds is an array containing historical bandwidth data.\n * The objects contained in the array are formatted as:\n *\n * {\n *   startTime: 'The starting timestamp of the request interval',\n *   length: 'The length in seconds of the request interval',\n *   bitrate: 'The bitrate we experienced during this interval'\n * }\n*/\nconst progressSpeeds = [];\n\n// The maximum amount of progress speed entries allowed within the `progressSpeeds` array.\nconst progressSpeedMaxLogs = 100;\n\nclass Fetcher {\n\n    /**\n     * Returns the download speed over the last x number of requests\n     *\n     * @param  {Number} howMany number of requests to average over\n     * @param  {Number} per     percentile value from 0 to 1\n     * @return {Number}         speed in bps (bits per second)\n     */\n    static getPercentileSpeed(howMany = 5, per = 0.8) {\n        const timesForPercentile = responseSpeeds.slice(-howMany);\n        return percentile(timesForPercentile, per);\n    }\n\n    static getAverageSpeed(howMany = 5, weights = []) {\n        const timesForAverage = responseSpeeds.slice(-howMany);\n        return average(timesForAverage, weights);\n    }\n\n    static getMedianSpeed(howMany = 5) {\n        const timesForMedian = responseSpeeds.slice(-howMany);\n        return median(timesForMedian);\n    }\n\n    static getResponseSpeeds() {\n        return responseSpeeds;\n    }\n\n    /**\n     * Returns an array with the latest XHR progress download speeds.\n     *\n     * @return {Array} An array with `progressSpeedMaxLogs` progress speed logs\n     */\n    static getProgressSpeeds() {\n        return progressSpeeds;\n    }\n\n    /**\n     * Returns the average bitrate experienced during the last X milliseconds\n     *\n     * @param  {Number} time - Time interval in milliseconds to look back on\n     * @return {Number} The average segment download bitrate\n     */\n    static getAverageBitrate(time = Infinity) {\n        const cutoff = Fetcher.getTime() - time;\n        const speeds = [];\n        const weights = [];\n\n        for (let index = progressSpeeds.length - 1; index >= 0; index--) {\n            const progressObject = progressSpeeds[index];\n\n            if (progressObject.startTime < cutoff) {\n                break;\n            }\n\n            speeds.push(progressObject.bitrate);\n        }\n\n        for (let speedIndex = 0; speeds.length > speedIndex; speedIndex++) {\n            weights.push(speeds.length - speedIndex);\n        }\n\n        return average(speeds, weights);\n    }\n\n    /**\n     * Returns the failed segments array\n     *\n     * @return {Array}\n     */\n    static getFailedSegments() {\n        return failedSegments;\n    }\n\n    /**\n     * Returns the successful segments array\n     *\n     * @return {Array}\n     */\n    static getSuccessfulSegments() {\n        return successfulSegments;\n    }\n\n    static getTime() {\n        if (typeof performance !== 'undefined') {\n            return performance.now();\n        }\n\n        return (new Date()).getTime();\n    }\n\n    // first retry 1.x seconds, 2nd retry 2.x and so on\n    static calculateExponentialBackoff(n) {\n        return (Math.pow(2, n) * 500) + (Math.round(Math.random() * 1000));\n    }\n\n    /**\n     * Fetcher constructor\n     *\n     * @param  {Number} [options.retryCount] - The maximum request rerty count\n     * @param  {Number} [options.parallel] - The maximum amount of parallel downloads\n     * @param  {Boolean} [options.includeWithSpeeds] - If downloads should be used in download speed calculations\n     */\n    constructor({ retryCount = 3, parallel = 1, includeWithSpeeds = true } = {}) {\n        this._queue = [];\n        this._activeXhrRequests = new Set();\n        this._retries = new WeakMap();\n        this._retryCount = retryCount;\n        this._running = false;\n        this._processingQueue = false;\n        this._parallel = parallel;\n        this._includeWithSpeeds = includeWithSpeeds;\n\n        // This per-instance WeakMap will keep track of bytes downloaded\n        // and is keyed off of activeXhrRequests\n        this._pendingFetchMap = new WeakMap();\n\n        eventManager(this);\n\n        // These are necessary to prevent us from trying to download segments\n        // when we are offline. Otherwise we will try to download them and fail\n        // and retry a few times and then they will never be retried once we\n        // come back online.\n        //\n        // @see https://github.vimeows.com/player/player/issues/1868\n        window.addEventListener('online', () => {\n            this.start();\n        });\n\n        window.addEventListener('offline', () => {\n            this.stop();\n\n            // If we don’t abort here then all fetches in progress will fail\n            // when we come back online and the mediasource scanner won’t know\n            // to try to download those segments again and those requests will\n            // fail if the URLs have expired.\n            this.abort();\n        });\n    }\n\n    get parallel() {\n        return this._parallel;\n    }\n\n    set parallel(num) {\n        this._parallel = num;\n    }\n\n    /**\n     * Returns the downloaded bytes, total bytes and percent downloaded for\n     * pending XHR requests.\n     *\n     * @return {Object} {[bytesTotal, bytesLoaded, percent]...}\n     */\n    get pendingFetches() {\n        const pendingFetches = [];\n        this._activeXhrRequests.forEach((xhr) => {\n            if (this._pendingFetchMap.get(xhr)) {\n                pendingFetches.push(this._pendingFetchMap.get(xhr));\n            }\n        });\n\n        return pendingFetches;\n    }\n\n    ////////////////////\n    // Public methods //\n    ////////////////////\n\n    add(segment, callback, prepend) {\n        this._addSegmentToQueue(segment, callback, prepend);\n        if (this._running && !this._processingQueue) {\n            this._processQueue();\n        }\n\n        return this;\n    }\n\n    start() {\n        if (this._running) {\n            return this;\n        }\n\n        this._running = true;\n        this._processQueue();\n\n        return this;\n    }\n\n    stop() {\n        this._running = false;\n\n        return this;\n    }\n\n    /**\n     * Aborts any queued requests and active requests for the passed stream\n     * @param  {Stream} [stream]\n     */\n    abort(stream = null) {\n        // if stream is null aborts = this._queue\n        const aborts = this._queue.filter((data) => {\n            return !stream || stream === data[0].stream;\n        });\n\n        aborts.forEach((data) => {\n            const [, , identifier] = this._getIdentifierFromData(data);\n            this.fire('downloadabort', identifier);\n        });\n\n        // if stream is null this._queue = []\n        this._queue = this._queue.filter((data) => {\n            return stream && stream !== data[0].stream;\n        });\n\n        this._activeXhrRequests.forEach((xhr) => {\n            if (stream && stream !== xhr.stream) {\n                return;\n            }\n            xhr.abort();\n        });\n    }\n    //////////////////////\n    // Internal methods //\n    //////////////////////\n\n    _insertAtPosition(segment, callback) {\n        // Find the position to insert this segment\n        //\n        // Note that the priority number here is actually backwards aka lower\n        // number means it will end up earlier in the queue. So 0 means it will\n        // be placed at the beginning.\n        let i = 0;\n        for (; i < this._queue.length; i++) {\n            const currentPriority = this._queue[i][0].priority;\n            if (currentPriority > segment.priority) {\n                break;\n            }\n        }\n\n        this._queue.splice(i, 0, [segment, callback]);\n    }\n\n    _addSegmentToQueue(segment, callback, prepend) {\n        // Prepend doesn't matter when using priority\n        if (segment.hasOwnProperty('priority')) {\n            this._insertAtPosition(segment, callback);\n            return;\n        }\n\n        this._queue[prepend ? 'unshift' : 'push']([segment, callback]);\n    }\n\n    _processQueue() {\n        if (!this._running) {\n            return;\n        }\n\n        this._processingQueue = true;\n        const numberToFetch = this._parallel - this._activeXhrRequests.size;\n        for (let i = 0; i < numberToFetch; i++) {\n            this._fetchOne();\n        }\n    }\n\n    _retry(xhr, data, identifier) {\n        const segment = data[0];\n        const callback = data[1];\n\n        if (!this._retries.get(segment)) {\n            this._retries.set(segment, 0);\n        }\n\n        this._retries.set(segment, this._retries.get(segment) + 1);\n\n        // Check if the maximum amount of retries have been attempted.\n        if (this._retries.get(segment) > this._retryCount) {\n            this._handleDownloadError(identifier, xhr.status, xhr.data.url, xhr.data.duration);\n            return;\n        }\n\n        const backoff = Fetcher.calculateExponentialBackoff(this._retries.get(segment));\n\n        console.info('Retrying', segment, 'after', backoff, 'ms');\n\n        setTimeout(() => {\n            const prepend = true;\n            this.add(segment, callback, prepend);\n        }, backoff);\n    }\n\n    /**\n     * Manages completed XMLHttpRequest.\n     *\n     * @param {XMLHttpRequest} xhr\n     * @param {Object} data\n     * @param {Object} identifier\n     * @param {Function} callback\n     */\n    _handleXHRResponse(xhr, data, identifier, callback) {\n        // For 5xx errors retry\n        if (xhr.status >= 500 && xhr.status < 600) {\n            this._retry(xhr, data, identifier);\n            return;\n        }\n\n        // For 4xx errors trigger an error\n        if (xhr.status >= 400 && xhr.status < 500) {\n            this._handleDownloadError(identifier, xhr.status, xhr.data.url, xhr.data.duration);\n            return;\n        }\n\n        this.fire('downloadend', identifier, {\n            headers: parseResponseHeaders(xhr.getAllResponseHeaders())\n        });\n        successfulSegments.push({\n            url: xhr.data.url,\n            status: xhr.status,\n            duration: xhr.data.duration\n        });\n        callback.call(this, new Uint8Array(xhr.response));\n    }\n\n    /**\n     * Called when a segment download request has\n     * returned a 404 status code.\n     *\n     * @param   {Object} identifier\n     * @param   {Number} status\n     * @param   {String} url\n     * @param   {Number} duration\n     */\n    _handleDownloadError(identifier, status, url, duration) {\n        failedSegments.push({\n            url,\n            status,\n            duration\n        });\n        this.fire('downloaderror', identifier, status);\n    }\n\n    _getIdentifierFromData(data) {\n        // Data looks like:\n        // [{\n        //     url,\n        //     byteRange,\n        //     id\n        // },\n        // callback\n        // ]\n        const callback = data[1];\n        const segment = data[0];\n        let identifier = segment;\n\n        if (segment.id) {\n            identifier = segment.id;\n        }\n\n        return [segment.url, segment.byteRange, identifier, callback];\n    }\n\n    _continueProcessingQueue() {\n        if (this._activeXhrRequests.size === 0 && this._queue.length === 0) {\n            this._processingQueue = false;\n            return;\n        }\n\n        if (this._activeXhrRequests.size < this._parallel) {\n            this._processQueue();\n        }\n    }\n\n    _fetchOne() {\n        if (this._queue.length === 0) {\n            this._processingQueue = false;\n            return;\n        }\n\n        let requestSendTime = null;\n        const data = this._queue.shift();\n        const [url, byteRange, identifier, callback] = this._getIdentifierFromData(data);\n        const includeWithSpeeds = data[0].includeWithBandwidthChecks;\n        const startTime = Fetcher.getTime();\n        const xhr = new XMLHttpRequest();\n        xhr.stream = data[0].stream;\n        xhr.data = {};\n        xhr.data.url = url;\n\n        let lastBytesLoaded = 0;\n        let lastTimeRecorded = Fetcher.getTime();\n\n        // Cannot use initial progress interval since it counts latency\n        let index = 0;\n\n        xhr.addEventListener('progress', (req) => {\n            if (req.lengthComputable) {\n                // Bits loaded since last progress\n                const bitsLoaded = (req.loaded - lastBytesLoaded) * 8;\n                const time = Fetcher.getTime();\n                const durationMS = time - lastTimeRecorded;\n                const durationSeconds = durationMS / 1000;\n                const bitrate = bitsLoaded / durationSeconds;\n\n                const intervalObject = {\n                    startTime: lastTimeRecorded,\n                    length: durationMS,\n                    bitrate,\n                    index\n                };\n\n                if (index > 0) {\n                    // Avoid appending too much to the progressSpeeds tracking array.\n                    if (progressSpeeds.length >= progressSpeedMaxLogs) {\n                        progressSpeeds.shift();\n                    }\n\n                    progressSpeeds.push(intervalObject);\n                }\n\n                lastTimeRecorded = time;\n                lastBytesLoaded = req.loaded;\n                index += 1;\n\n                this._pendingFetchMap.set(xhr, {\n                    bytesTotal: req.total,\n                    bytesLoaded: req.loaded,\n                    percent: req.loaded / req.total,\n                    identifier\n                });\n\n                this.fire('progress', identifier);\n            }\n        });\n\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        if (byteRange) {\n            xhr.setRequestHeader('Range', `bytes=${byteRange}`);\n        }\n\n        // Called when the XMLHttpRequest transaction completes successfully.\n        xhr.onload = (e) => {\n            const duration = Date.now() - requestSendTime;\n            xhr.data.duration = duration;\n            this._activeXhrRequests.delete(xhr);\n\n            // If a segment is done being downloaded, clear limbo\n            this._pendingFetchMap.delete(xhr);\n\n            const elapsedTimeInSeconds = (Fetcher.getTime() - startTime) / 1000;\n\n            // If the size is greater than 40kb then include it in the\n            // response speeds.  This is cause for init segments the size\n            // is smaller and a lot of the response time is network time so\n            // the actual calculated bit rate is not useful.\n            const size = e.target.response.byteLength;\n            if (size > 40960) {\n                const sizeInBits = size * 8;\n                const bitsPerSecond = sizeInBits / elapsedTimeInSeconds;\n\n                // only keep last 100\n                if (responseSpeeds.length > 100) {\n                    responseSpeeds.shift();\n                }\n\n                if (this._includeWithSpeeds && includeWithSpeeds) {\n                    responseSpeeds.push(bitsPerSecond);\n                }\n            }\n\n            this._handleXHRResponse(xhr, data, identifier, callback);\n            this._continueProcessingQueue();\n        };\n\n        // Fires when there is a failure on the network level.\n        // If the error only exists on the application level,\n        // e.g., an HTTP error code is sent, then onload still fires.\n        xhr.onerror = () => {\n            const duration = Date.now() - requestSendTime;\n            xhr.data.duration = duration;\n            this._activeXhrRequests.delete(xhr);\n            this._pendingFetchMap.delete(xhr);\n            this._retry(xhr, data, identifier);\n            this._continueProcessingQueue();\n        };\n\n        // Called when an XMLHttpRequest transaction is aborted,\n        // such as when the XMLHttpRequest.abort() function is called.\n        xhr.onabort = () => {\n            const duration = Date.now() - requestSendTime;\n            xhr.data.duration = duration;\n            failedSegments.push({\n                url,\n                status: 'abort',\n                duration\n            });\n            // If a segment has been aborted, clear limbo\n            this._pendingFetchMap.delete(xhr);\n\n            this._activeXhrRequests.delete(xhr);\n\n            this.fire('downloadabort', identifier);\n\n            if (this._activeXhrRequests.size === 0 && this._queue.length === 0) {\n                this._processingQueue = false;\n            }\n\n            // This is because there might be objects in the queue\n            // that belong to the non-aborted stream that we want to examine\n            this._continueProcessingQueue();\n        };\n\n        this.fire('downloadstart', identifier);\n\n        this._activeXhrRequests.add(xhr);\n        requestSendTime = Date.now();\n        xhr.send();\n    }\n}\n\nexport default Fetcher;\n","import eventManager from 'eventmanager';\n\nconst segmentDuration = 6;\n\nclass Buffer {\n\n    /**\n     * The Buffer object is a wrapper around the native SourceBuffer object.\n     * It queries streams to get what segments to append to the buffer and handles switching between streams.\n     *\n     * @param  {MediaSorcerer} sorcerer\n     */\n    constructor(sorcerer) {\n        eventManager(this);\n\n        this._sorcerer = sorcerer;\n        this._sourceBuffer = null;\n        this._activeStreamIndex = null;\n        this._needsStreamSwitch = false;\n        this._needInitSegment = true;\n        this._lastAppended = null;\n        this._toRemove = [];\n        this._streams = [];\n        this._quotaExceeded = false;\n        this._quotaExceededTimer = null;\n        this._appendingFinalSegment = false;\n        this._finalSegmentTime = undefined;\n        this._addingInitSegment = false;\n        this._isFirstSegment = true;\n        this._bufferState = {};\n\n        this._sorcerer.on('durationset', this._onDurationSet.bind(this));\n    }\n\n    get streams() {\n        return this._streams;\n    }\n\n    get activeStreamIndex() {\n        return this._activeStreamIndex;\n    }\n\n    get sourceBuffer() {\n        return this._sourceBuffer;\n    }\n\n    set sourceBuffer(sourceBuffer) {\n        this._sourceBuffer = sourceBuffer;\n        this._attachEvents();\n        this.fire('sourcebufferattach');\n    }\n\n    ////////////////////\n    // Public methods //\n    ////////////////////\n\n    /**\n     * Adds a stream object to this buffer.\n     *\n     * @param {Stream} stream A Stream object.\n     */\n    addStream(stream) {\n        stream.on('segmentadd', () => this._process());\n\n        const index = this._streams.push(stream) - 1;\n        stream.index = index;\n\n        if (this._activeStreamIndex === null) {\n            this._setActiveIndex(index);\n            this._needsStreamSwitch = true;\n        }\n    }\n\n    /**\n     * Retrieves the index of the stream in the buffer at input time.\n     *\n     * @param {Number} time - The video time to retrieve buffer\n     * @return {Number}\n     */\n    streamIndexAtTime(time) {\n        // In Live, this is what the bufferState looks like\n        // so we can get the active stream at the current time instead\n        if (this._bufferState[undefined]) {\n            return { stream: this.activeStreamIndex };\n        }\n\n        return this._bufferState[Math.floor(time / segmentDuration)];\n    }\n\n    /**\n     * Switches the currently active stream to the specified stream or stream index.\n     *\n     * @param {Object} stream A Stream object or numeric index of which stream to switch to.\n     * @param {Boolean} [abort] If the previous stream should be aborted.\n     * @return {Promise} A Promise that will resolve when the first segment of the new stream has been appended to the buffer.\n     */\n    switchTo(stream, abort = true) {\n        let index = stream;\n        if (typeof stream === 'object') {\n            index = stream.index;\n        }\n\n        let indexHasChanged = this._activeStreamIndex !== index;\n        const shouldAbort = indexHasChanged;\n\n        // An index is set up by default when the first stream has been added\n        // and that becomes the active index. This means if we later decide to\n        // switch to that index we need to make sure to still fire the\n        // streamswitch event before playback begins.\n        if (!indexHasChanged && this._needsStreamSwitch) {\n            indexHasChanged = true;\n        }\n\n        if (indexHasChanged) {\n            // Assuming we have gotten here that means we don't need to force\n            // another streamswitch event in the future\n            this._needsStreamSwitch = false;\n\n            const previousStreamIndex = this._activeStreamIndex;\n            const previousStream = this._streams[previousStreamIndex];\n\n            if (previousStream && shouldAbort && abort) {\n                previousStream.abort();\n            }\n\n            this._switchToIndex = index;\n            this._setActiveIndex(index);\n        }\n\n        this._process();\n\n        return new Promise((resolve) => {\n            if (!indexHasChanged) {\n                resolve();\n                return;\n            }\n\n            this._resolveSwitchComplete = () => {\n                if (this._switchToIndex !== index) {\n                    return;\n                }\n\n                this._resolveSwitchComplete = null;\n                resolve();\n                this.fire('streamchange', index);\n            };\n        });\n    }\n\n    /**\n     * Returns if the supplied time is within the source buffer.\n     *\n     * @param {Number} time - The time to lookup in seconds.\n     * @return {Boolean}\n     */\n    isTimeInBuffer(time) {\n        for (let i = 0; i < this.sourceBuffer.buffered.length; i++) {\n            const bufferStart = this.sourceBuffer.buffered.start(i);\n            const bufferEnd = this.sourceBuffer.buffered.end(i);\n\n            if (bufferStart <= time && bufferEnd >= time) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns if the final segment has been appended for the purpose of firing\n     * MediaSource.endOfStream().\n     *\n     * @return {Boolean}\n     */\n    hasAppendedFinalSegment() {\n        if (this._finalSegmentTime === undefined) {\n            return false;\n        }\n\n        return this.isTimeInBuffer(this._finalSegmentTime);\n    }\n\n    /**\n     * Clears out all segments in the queue for all streams\n     * belonging to this buffer.\n     */\n    clear() {\n        this._streams.forEach((stream) => {\n            stream.clear();\n        });\n    }\n\n    /**\n     * Removes the allocated buffer between two playback times.\n     *\n     * @param  {Number} startTime The video time in seconds to start removal.\n     * @param  {Number} [endTime] The video time in seconds to end removal.\n     * @return {Promise}\n     */\n    remove(startTime, endTime = this._sorcerer._mediaSource.duration) {\n        return new Promise((resolve, reject) => {\n            this._toRemove.push([startTime, endTime, resolve]);\n            this._process();\n        });\n    }\n\n    /////////////////////\n    // Private methods //\n    /////////////////////\n\n    /**\n     * Initializes the buffer tracking object.\n     */\n    _onDurationSet() {\n        const duration = this._sorcerer._mediaSource.duration;\n        let segments = Math.floor(duration / segmentDuration);\n        segments += (segmentDuration % duration) > 1 ? 1 : 0;\n        for (let i = 0; i < segments; i++) {\n            this._bufferState[i] = {\n                stream: null,\n                segment: i,\n                type: 'video'\n            };\n        }\n    }\n\n    _attachEvents() {\n        this.bound = {\n            handleUpdateEnd: this._handleUpdateEnd.bind(this)\n        };\n\n        this._sourceBuffer.addEventListener('updateend', this.bound.handleUpdateEnd);\n        this._sorcerer.on('endofstream', () => {\n            this._handleUpdateEnd();\n        });\n\n        this._sorcerer.on('ended', this.bound.handleEnded);\n    }\n\n    _handleUpdateEnd(e) {\n        if (this._appendingFinalSegment) {\n            this._finalSegmentTime = this._sourceBuffer.buffered.end(this._sourceBuffer.buffered.length - 1);\n            this._sorcerer._fireStreamHasEnded();\n            this._appendingFinalSegment = false;\n        }\n\n        if (this._lastAppended) {\n            this.fire('appendbufferend', this._lastAppended);\n            this._lastAppended = null;\n\n            if (this._resolveSwitchComplete) {\n                this._resolveSwitchComplete();\n            }\n        }\n        this._process();\n    }\n\n    _removeEventListeners() {\n        // It is possible for MediaSorcerer.destroy() to be called as a result\n        // of failing to create sourceBuffers because the codec is not supported\n        // by the browser. In that case a source buffer will never be added so\n        // there won't be any bound events to actually remove since\n        // _attachEvents was never actually called. This makes sure we have\n        // bound events before trying to remove them.\n        //\n        // @see https://github.vimeows.com/player/player/issues/1744\n        if (!this.bound) {\n            return;\n        }\n\n        if (this._sourceBuffer) {\n            this._sourceBuffer.removeEventListener('updateend', this.bound.handleUpdateEnd);\n        }\n\n        this._sorcerer.off('endofstream', this.bound.handleUpdateEnd);\n        this._sorcerer.off('ended', this.bound.handleEnded);\n    }\n\n    _setActiveIndex(index) {\n        // Anytime we switch streams, we need the init segment\n        this._needInitSegment = true;\n        this._activeStreamIndex = index;\n        this._sorcerer._frameDropper.streamIndex = index;\n    }\n\n    /* eslint-disable complexity */\n    _process() {\n        const activeStream = this._streams[this._activeStreamIndex];\n\n        if (!this._sourceBuffer) {\n            this.on('sourcebufferattach', this._process);\n            return;\n        }\n\n        if (!activeStream) {\n            return;\n        }\n\n        // We can only append to the source buffer if the ready state is open\n        // or ended, but not closed.\n        //\n        // The source will be reopened if it is in the ended state\n        //\n        // http://www.w3.org/TR/media-source/#widl-MediaSource-readyState\n        // http://www.w3.org/TR/media-source/#sourcebuffer-prepare-append\n        if (this._sorcerer._mediaSource.readyState === 'closed') {\n            return;\n        }\n\n        const sourceBuffer = this._sourceBuffer;\n        if (sourceBuffer.updating) {\n            return;\n        }\n\n        if (this._toRemove.length) {\n            const [startTime, endTime, resolve] = this._toRemove.shift();\n            const self = this;\n            sourceBuffer.addEventListener('updateend', function handleUpdateEnd(e) {\n                sourceBuffer.removeEventListener('updateend', handleUpdateEnd);\n                resolve();\n\n                clearTimeout(self._quotaExceededTimer);\n                self._quotaExceededTimer = setTimeout(() => {\n                    self._quotaExceeded = false;\n                    self._process();\n                }, 5000);\n            });\n\n            const start = startTime;\n            sourceBuffer.remove(start, endTime);\n            return;\n        }\n\n        // If we are part of a quotaExceeded removal then we should not do\n        // anything\n        if (this._quotaExceeded) {\n            return;\n        }\n\n        // init segment should always be appended before other segments\n        if (this._addingInitSegment) {\n            return;\n        }\n\n        if (this._needInitSegment) {\n            this._addingInitSegment = true;\n            activeStream.getInitSegment().then((buffer) => {\n                // ignore init segments for updateend events\n                this._lastAppended = null;\n                sourceBuffer.appendBuffer(buffer);\n                this._addingInitSegment = false;\n                return buffer;\n            }).catch((err) => {\n                console.error(err);\n                this._addingInitSegment = false;\n            });\n            this._needInitSegment = false;\n            return;\n        }\n\n        const toAppend = activeStream.getNextSegment();\n        // toAppend can be null when loading init segment and no other\n        // segments have loaded yet\n        if (toAppend === null) {\n            return;\n        }\n\n        const identifier = activeStream.getIdForSegment(toAppend);\n        const isFinalSegment = activeStream.isFinal(toAppend);\n\n        if (isFinalSegment) {\n            this._appendingFinalSegment = true;\n        }\n\n        this._lastAppended = identifier;\n        this.fire('appendbufferstart', identifier);\n\n        try {\n            sourceBuffer.appendBuffer(toAppend);\n            this._bufferState[identifier.segment] = identifier;\n\n            if (this._isFirstSegment) {\n                this._isFirstSegment = false;\n                this.fire('initialbufferstart');\n            }\n        }\n        catch (e) {\n            if (e.name === 'QuotaExceededError') {\n                this._quotaExceeded = true;\n                console.warn('QuotaExceededError');\n\n                // When you call remove on a SourceBuffer it has to be behind\n                // the currentTime by a certain amount otherwise you could run\n                // into issues where you end up removing the video in the buffer\n                // at the currentTime since the browser may remove up until the\n                // nearest keyframe to the endTime. Six seconds is an okay\n                // threshold for now.\n                const removalThreshold = 6;\n                if (this._sorcerer._video.currentTime > removalThreshold) {\n                    const startTime = 0;\n                    const endTime = this._sorcerer._video.currentTime - removalThreshold;\n                    console.log(`Removing buffer from ${startTime} to ${endTime}…`);\n                    this._sorcerer.removeBuffer(startTime, endTime);\n                }\n\n                activeStream._readyToAppend.unshift(toAppend);\n            }\n        }\n    }\n    /* eslint-enable complexity */\n\n}\n\nexport default Buffer;\n","import eventManager from 'eventmanager';\nimport Fetcher from './fetcher';\n\nclass Stream {\n\n    // A string (url) or object (url + byteRange) is valid\n    static isValidSegmentUrl(segment) {\n        if (typeof segment === 'string') {\n            return true;\n        }\n\n        if (typeof segment.url === 'string' && typeof segment.byteRange === 'string') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The Stream object is a representation of a specific quality of audio or video.\n     *\n     * @param {UInt8Array|String|Object} initSegment A URL or ArrayBuffer representing the init segment for this stream.\n     * @param {String} [codec] The codec string originally passed in when creating the stream with MediaSorcerer.addStream.\n     * @param {Fetcher} [fetcher] A optional reference to a Fetcher instance.\n     */\n    constructor(initSegment, codec = '', fetcher = new Fetcher()) {\n        eventManager(this);\n\n        this._readyToAppend = [];\n        this._initSegment = null;\n        this._index = NaN;\n        this._codec = codec;\n        this._fetcher = fetcher;\n        this._fetcher.start();\n\n        this._bufferData = new WeakMap();\n        this._segmentToId = {};\n\n        this._getInitSegmentPromise = new Promise((resolve, reject) => {\n            if (Stream.isValidSegmentUrl(initSegment)) {\n                this._fetcher.add({\n                    url: initSegment.url || initSegment,\n                    byteRange: initSegment.byteRange,\n                    id: null,\n                    stream: this\n                }, (buffer) => {\n                    this._initSegment = buffer;\n                    resolve(buffer);\n                });\n                return;\n            }\n\n            this._initSegment = initSegment;\n            resolve(initSegment);\n        });\n    }\n\n    get codec() {\n        return this._codec;\n    }\n\n    set codec(value) {\n        this._codec = value;\n    }\n\n    get index() {\n        return this._index;\n    }\n\n    set index(value) {\n        this._index = value;\n    }\n\n    get pendingFetches() {\n        return this._fetcher.pendingFetches;\n    }\n\n    getIdForSegment(segment) {\n        if (Stream.isValidSegmentUrl(segment)) {\n            return this._segmentToId[segment];\n        }\n\n        return this._bufferData.get(segment).id;\n    }\n\n    isFinal(segment) {\n        return this._bufferData.get(segment).final;\n    }\n\n    /**\n     * Adds a segment to a stream.\n     *\n     * @param {UInt8Array|String|Object} segment - Actual buffer data (initSegment), segment url, or {url, byteRange}\n     * @param {Object} [options.identifier] - The stream indentifier object\n     * @param {Boolean} [options.isFinalSegment] - Whether or not this is the final segment\n     * @param {Boolean} [options.loadOnly] - If the segment should be preloaded\n     * @param {Number} [options.priority] - The segment priority. lower number means it will end up earlier in\n     *                                     the queue. So 0 means it will be placed at the beginning.\n     * @param {Boolean} [options.includeWithBandwidthChecks] - If this download of this segment should be included in\n     *                                                        bandwidth checks.\n     * @return {Void}\n     */\n    addSegment(segment, { identifier = null, isFinalSegment = false, loadOnly = false, priority = 0, includeWithBandwidthChecks = true } = {}) {\n\n        return new Promise((resolve, reject) => {\n            if (Stream.isValidSegmentUrl(segment)) {\n                this._segmentToId[segment] = identifier || segment;\n\n                this.fire('queued', this.getIdForSegment(segment));\n\n                this._fetcher.add({\n                    url: segment.url || segment,\n                    byteRange: segment.byteRange,\n                    id: this.getIdForSegment(segment),\n                    stream: this,\n                    includeWithBandwidthChecks,\n                    priority\n                }, (buffer) => {\n                    this._bufferData.set(buffer, {\n                        id: identifier || segment,\n                        final: isFinalSegment\n                    });\n\n                    this._readyToAppend.push(buffer);\n\n                    this.fire('bufferqueueadd', this.getIdForSegment(segment));\n\n                    if (!loadOnly) {\n                        this.fire('segmentadd');\n                    }\n\n                    resolve();\n                });\n\n                return;\n            }\n\n            this._bufferData.set(segment, {\n                id: identifier,\n                final: isFinalSegment\n            });\n\n            this._readyToAppend.push(segment);\n            this.fire('bufferqueueadd', identifier);\n\n            resolve();\n        });\n    }\n\n    clear() {\n        this._readyToAppend = [];\n    }\n\n    abort() {\n        // This has to wait on the init segment to be ready because otherwise\n        // if abort is called while the init segment is downloaded it will abort\n        // the init segment request.\n        this._getInitSegmentPromise.then(() => {\n            this._fetcher.abort(this);\n            return;\n        }).catch((error) => {\n            console.error(error);\n        });\n    }\n\n    getNextSegment() {\n        if (this._readyToAppend.length === 0) {\n            return null;\n        }\n\n        return this._readyToAppend.shift();\n    }\n\n    getInitSegment() {\n        return this._getInitSegmentPromise;\n    }\n}\n\nexport default Stream;\n","import { average, median } from './util';\n\n/**\n * @fileoverview Manager class that checks a video for dropped frames\n */\nclass FrameDropper {\n    constructor(video) {\n        this._video = video;\n        this._running = false;\n        this._droppedFramesTimeout = null;\n\n        this._droppedFrameData = {};\n        this._decodedFrameData = {};\n        this._droppedFrames = 0;\n        this._decodedFrames = 0;\n\n        // Key to collect dropped frames on\n        // Might be worth it to not let an instance of this class start\n        // without explicitly setting the key\n        this._streamIndex = 'default';\n\n        this.bound = {\n            startCheckingDroppedFrames: this._startCheckingDroppedFrames.bind(this),\n            stopCheckingDroppedFrames: this._stopCheckingDroppedFrames.bind(this)\n        };\n    }\n\n    get streamIndex() {\n        return this._streamIndex;\n    }\n\n    set streamIndex(value) {\n        this._streamIndex = value;\n    }\n\n    ////////////////////\n    // Public methods //\n    ////////////////////\n\n    start() {\n        this._startCheckingDroppedFrames();\n        return this;\n    }\n\n    stop() {\n        this._stopCheckingDroppedFrames();\n        return this;\n    }\n\n    destroy() {\n        this._stopCheckingDroppedFrames();\n        this._removeEvents();\n    }\n\n    /**\n     * Get sample of dropped frames on a specific key index\n     *\n     * @param  {Number} howMany Amount of items to sample\n     * @param  {Mixed} streamIndex      key identifier to get sampled frames from\n     * @param  {String} type    type of sampling, ie median or average\n     * @return {Number}         Calculated amount of dropped frames\n     */\n    getDroppedFrameRate(howMany, streamIndex, type = 'average') {\n        const rates = this._droppedFrameData[streamIndex];\n\n        if (!rates) {\n            return 0;\n        }\n\n        if (rates.length < howMany) {\n            return 0;\n        }\n\n        const ratesForAverage = rates.slice(-howMany);\n        if (type === 'median') {\n            return median(ratesForAverage);\n        }\n\n        return average(ratesForAverage);\n    }\n\n    getDroppedFrameTotal() {\n        return {\n            dropped: this._getTotalDroppedFrames(),\n            total: this._getTotalFrames()\n        };\n    }\n\n    /////////////////////\n    // Private methods //\n    /////////////////////\n\n    _attachEvents() {\n        this._video.addEventListener('playing', this.bound.startCheckingDroppedFrames);\n        this._video.addEventListener('pause', this.bound.stopCheckingDroppedFrames);\n        this._video.addEventListener('ended', this.bound.stopCheckingDroppedFrames);\n    }\n\n    _removeEvents() {\n        this._video.removeEventListener('playing', this.bound.startCheckingDroppedFrames);\n        this._video.removeEventListener('pause', this.bound.stopCheckingDroppedFrames);\n        this._video.removeEventListener('ended', this.bound.stopCheckingDroppedFrames);\n    }\n\n    _startCheckingDroppedFrames() {\n        this._running = true;\n        this._checkDroppedFrames();\n    }\n\n    _stopCheckingDroppedFrames() {\n        this._running = false;\n    }\n\n    _checkDroppedFrames() {\n        if (!this._running || this._streamIndex === null) {\n            return;\n        }\n\n        clearTimeout(this._droppedFramesTimeout);\n\n        const totalDropped = this._getTotalDroppedFrames();\n        const droppedPerSecond = totalDropped - this._droppedFrames;\n\n        this._droppedFrames = totalDropped;\n\n        const totalDecoded = this._getTotalDecodedFrames();\n        const decodedPerSecond = totalDecoded - this._decodedFrames;\n        this._decodedFrames = totalDecoded;\n\n        if (!this._droppedFrameData[this._streamIndex]) {\n            this._droppedFrameData[this._streamIndex] = [];\n        }\n\n        if (!this._decodedFrameData[this._streamIndex]) {\n            this._decodedFrameData[this._streamIndex] = [];\n        }\n\n        if (this._droppedFrameData[this._streamIndex].length > 100) {\n            this._droppedFrameData[this._streamIndex].shift();\n        }\n\n        if (this._decodedFrameData[this._streamIndex].length > 100) {\n            this._decodedFrameData[this._streamIndex].shift();\n        }\n\n        this._droppedFrameData[this._streamIndex].push(droppedPerSecond);\n        this._decodedFrameData[this._streamIndex].push(decodedPerSecond);\n\n        this._droppedFramesTimeout = setTimeout(() => {\n            this._checkDroppedFrames();\n        }, 1000);\n    }\n\n    _getTotalDroppedFrames() {\n        if (typeof this._video.getVideoPlaybackQuality === 'function') {\n            return this._video.getVideoPlaybackQuality().droppedVideoFrames;\n        }\n\n        return this._video.webkitDroppedFrameCount || 0;\n    }\n\n    _getTotalFrames() {\n        if (typeof this._video.getVideoPlaybackQuality === 'function') {\n            return this._video.getVideoPlaybackQuality().totalVideoFrames;\n        }\n\n        return this._video.webkitDecodedFrameCount || 0;\n    }\n\n    _getTotalDecodedFrames() {\n        if (typeof this._video.getVideoPlaybackQuality === 'function') {\n            const quality = this._video.getVideoPlaybackQuality();\n            return quality.totalVideoFrames - quality.droppedVideoFrames - quality.corruptedVideoFrames;\n        }\n\n        return this._video.webkitDecodedFrameCount || 0;\n    }\n}\n\nexport default FrameDropper;\n","import Fetcher from './fetcher';\nimport Buffer from './buffer';\nimport Stream from './stream';\nimport FrameDropper from './framedropper';\nimport eventManager from 'eventmanager';\n\nclass MediaSorcerer {\n\n    /**\n     * Creates a new MediaSorcerer object.\n     *\n     * @param  {HTMLElement} video A reference to the video tag element on the page that you want to use MediaSource with.\n     * @param  {Object} [options] Options for MediaSorcerer. Currently the only supported option is the video duration.\n     */\n    constructor(video, options = {}) {\n        this._video = video;\n        this._options = options;\n\n        eventManager(this);\n\n        // In Chrome there is an issue with floats where the duration may show\n        // up as 186.773333333 and the currentTime at the end shows up as\n        // 186.773333.\n        //\n        // There are also cases where the duration might be 16.766 and the\n        // currentTime comes back as 16.765999\n        //\n        // In order to work around this we need to change the duration passed to\n        // the media source object.\n        //\n        // Why we need to ceil this to the nearest hundred is beyond me.\n        // Somehow by changing it, it causes Chrome to correctly map the\n        // video.currentTime to the video.duration. Otherwise there are floating\n        // point rounding errors.\n        if (this._options.duration) {\n            this._options.duration = Math.ceil(this._options.duration * 100) / 100;\n        }\n\n        this._bufferCount = 0;\n        this._frameDropper = new FrameDropper(video);\n        this._mediaSource = new MediaSource();\n        this._fetcher = new Fetcher({ parallel: 1 });\n        this._video.src = URL.createObjectURL(this._mediaSource);\n        this._buffersForCodec = {};\n        this._readyPromiseResolve = null;\n\n        this._attachEvents();\n    }\n\n    /**\n     * A reference to the actual MediaSource object being used for playback.\n     *\n     * @return {MediaSource}\n     */\n    get mediaSource() {\n        return this._mediaSource;\n    }\n\n    /**\n     * A shortcut for accessing Stream objects when there is a single (video) buffer.\n     *\n     * @return {Array|Buffer}\n     */\n    get streams() {\n        if (this._bufferCount === 1) {\n            return this.video.streams;\n        }\n\n        console.error('The streams property on MediaSorcerer only works with single streams');\n        return false;\n    }\n\n    /**\n     * A shortcut for accessing the currently active stream index when there is a single (video) buffer.\n     *\n     * @return {Number|Boolean}\n     */\n    get activeStreamIndex() {\n        if (this._bufferCount === 1) {\n            return this.video.activeStreamIndex;\n        }\n\n        console.error('The activeStreamIndex property on MediaSorcerer only works with single streams');\n        return false;\n    }\n\n    /**\n     * A reference to the video buffer object or false if there is no video buffer.\n     *\n     * @return {Buffer|Boolan}\n     */\n    get video() {\n        if (this._buffersForCodec.video) {\n            return this._buffersForCodec.video;\n        }\n\n        console.error('No video streams have been added to MediaSorcerer');\n        return false;\n    }\n\n    /**\n     * A reference to the audio buffer object or false if there is no audio buffer.\n     *\n     * @return {Buffer|Boolean}\n     */\n    get audio() {\n        if (this._buffersForCodec.audio) {\n            return this._buffersForCodec.audio;\n        }\n\n        console.error('No audio streams have been added to MediaSorcerer');\n        return false;\n    }\n\n    ////////////////////\n    // Public methods //\n    ////////////////////\n\n    /**\n     * A shortcut for calling Buffer.switchTo when there is only a single (video) buffer\n     *\n     * @param  {Object} stream\n     * @return {Boolean|Promise}\n     */\n    switchTo(stream) {\n        if (this._bufferCount === 1) {\n            return this.video.switchTo(stream);\n        }\n\n        console.error('The switch method on MediaSorcerer only works with single streams');\n        return false;\n    }\n\n    /**\n     * Gets the current download speed for the viewer in bps (bits per second).\n     *\n     * Available Options\n     *   type {String} The way to calculate the speed (“average”, “median”, or “percentile”).\n     *   howMany {Number} The number of recent speeds to include when doing the calculation.\n     *   weights {Array} An array of weights to use to calculate a weighted average.\n     *   percentile {Number} The percentile to use from 0 to 1 if you want a percentile speed.\n     *\n     * @param {Object} options An object containing options\n     * @return {Number}\n     */\n    getCurrentSpeed({ type = 'average', howMany = 10, weights = [], percentile = null } = {}) {\n        if (type === 'average') {\n            return Fetcher.getAverageSpeed(howMany, weights);\n        }\n\n        if (type === 'median') {\n            return Fetcher.getMedianSpeed(howMany);\n        }\n\n        return Fetcher.getPercentileSpeed(howMany, percentile);\n    }\n\n    /**\n     * Returns the average segment download bitrate.\n     *\n     * @param  {Number} [time] - Time interval in milliseconds to look back on\n     * @return {Number} The average segment download bitrate\n     */\n    getAverageDownloadBitrate(time = 1000) {\n        return Fetcher.getAverageBitrate(time);\n    }\n\n    /**\n     * Returns an array of (up to) the last 100 raw response speeds (in bits per second)\n     * in case you want to use them in a way that getCurrentSpeed will provide.\n     *\n     * @return {Array}\n     */\n    getResponseSpeeds() {\n        return Fetcher.getResponseSpeeds();\n    }\n\n    /**\n     * Returns the failed segments array\n     *\n     * @return {Array}\n     */\n    getFailedSegments() {\n        return Fetcher.getFailedSegments();\n    }\n\n    /**\n     * Returns the successful segments array\n     *\n     * @return {Array}\n     */\n    getSuccessfulSegments() {\n        return Fetcher.getSuccessfulSegments();\n    }\n\n    /**\n     * Returns the rate of dropped frames over the last x number of seconds.\n     *\n     * @param  {Number} howMany Number of seconds to look at.\n     * @param  {Number} [streamIndex] Which stream to check.\n     * @param  {String} [type] How to calculate the number of dropped frames (“average”, or “median”).\n     * @return {Number}\n     */\n    getDroppedFrameRate(howMany, streamIndex = this.activeStreamIndex, type = 'average') {\n        return this._frameDropper.getDroppedFrameRate(howMany, streamIndex, type);\n    }\n\n    /**\n     * Returns the total number of dropped frames throughout the entire playback session.\n     *\n     * @return {Number}\n     */\n    getDroppedFrameTotal() {\n        return this._frameDropper.getDroppedFrameTotal();\n    }\n\n    /**\n     * Clears out all buffers that are currently in the queue to be\n     * appended across all buffers and streams.\n     */\n    clear() {\n        for (const type in this._buffersForCodec) {\n            this._buffersForCodec[type].clear();\n        }\n    }\n\n    /**\n     * Returns a stream object from a given video time.\n     *\n     * @param  {Number} time - The video time to lookup\n     * @param  {String} type - The type of stream to reference ('audio' or 'video')\n     * @return {Object}\n     */\n    streamIndexAtTime(time, type) {\n        if (!this._buffersForCodec[type].streamIndexAtTime(time)) {\n            return null;\n        }\n\n        return this._buffersForCodec[type].streamIndexAtTime(time).stream;\n    }\n\n    /**\n     * Calls Buffer.remove on each Buffer object that has been created.\n     *\n     * @param  {Number} [startTime]\n     * @param  {Number} [endTime]\n     * @return {Promise}\n     */\n    removeBuffer(startTime = 0, endTime = this._video.duration) {\n        if (startTime > endTime) {\n            return Promise.resolve();\n        }\n\n        const promises = [];\n        for (const type in this._buffersForCodec) {\n            promises.push(this._buffersForCodec[type].remove(startTime, endTime));\n        }\n\n        return Promise.all(promises);\n    }\n\n    /**\n     * Creates a new Stream object and adds it to the corresponding Buffer object.\n     *\n     * @param {String} codec The codec string corresponding to the stream you are creating.\n     * @param {String} initSegment A URL or ArrayBuffer object representing the init segment for this stream.\n     * @return {Object} The newly created stream object.\n     */\n    addStream(codec, initSegment) {\n        const codecType = this._getCodecType(codec);\n        if (!this._buffersForCodec[codecType]) {\n            this._bufferCount += 1;\n            const buffer = new Buffer(this, codecType);\n            this._buffersForCodec[codecType] = buffer;\n\n            this.readyPromise.then(() => {\n                let sourceBuffer;\n                try {\n                    sourceBuffer = this._mediaSource.addSourceBuffer(codec);\n                }\n                catch (e) {\n\n                    // if we have hit the maximum number then return the last\n                    // used video source buffer\n                    if (e.code === 22) {\n                        sourceBuffer = this._buffersForCodec[codecType];\n                    }\n                    else {\n                        console.error(e);\n                        this.fire('srcnotsupported', e);\n                        return;\n                    }\n                }\n\n                // This prevents a segment from being able to be added beyond a\n                // certian time.\n                if (this._options.duration) {\n                    sourceBuffer.appendWindowEnd = this._options.duration;\n                }\n\n                buffer.sourceBuffer = sourceBuffer;\n\n                return;\n            }).catch((error) => {\n                console.error(error);\n            });\n\n            ['appendbufferstart', 'appendbufferend', 'streamchange', 'initialbufferstart'].forEach((evt) => {\n                buffer.on(evt, (identifier) => {\n                    this.fire(evt, identifier);\n                });\n            });\n        }\n\n        const stream = new Stream(initSegment, codec, this._fetcher);\n\n        // Might not need 'queued' event soon since addSegment has been\n        // promisified.\n        ['queued', 'bufferqueueadd'].forEach((evt) => {\n            stream.on(evt, (identifier) => {\n                this.fire(evt, identifier);\n            });\n        });\n\n        this._buffersForCodec[codecType].addStream(stream);\n\n        return stream;\n    }\n\n    /**\n     * Destroys the MediaSorcerer instance and removes all event listeners.\n     */\n    destroy() {\n        this.clear();\n        this._removeEventListeners();\n\n        this._frameDropper.destroy();\n        this._fetcher.abort();\n\n        if (this._video.src) {\n            URL.revokeObjectURL(this._video.src);\n        }\n    }\n\n    /////////////////////\n    // Private methods //\n    /////////////////////\n\n    _attachEvents() {\n        this.bound = {\n            handleSourceOpen: this._handleSourceOpen.bind(this)\n        };\n\n        this.readyPromise = new Promise((resolve, reject) => {\n            this._readyPromiseResolve = resolve;\n            this._mediaSource.addEventListener('sourceopen', this.bound.handleSourceOpen);\n        });\n\n        ['downloadstart', 'downloadend', 'downloadabort', 'downloaderror', 'progress'].forEach((event) => {\n            this._fetcher.on(event, (...data) => {\n                this.fire(event, ...data);\n            });\n        });\n    }\n\n    _sourceBuffersAreUpdating() {\n        for (let i = 0; i < this._mediaSource.sourceBuffers.length; i++) {\n            if (this._mediaSource.sourceBuffers[i].updating) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    _fireStreamHasEnded() {\n        for (const type in this._buffersForCodec) {\n            const buffer = this._buffersForCodec[type];\n            if (!buffer.hasAppendedFinalSegment()) {\n                return;\n            }\n        }\n\n        // If the ready state is not open or there are source buffers updating\n        // we cannot call endOfStream\n        //\n        // @see http://www.w3.org/TR/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error\n        if (this._mediaSource.readyState !== 'open') {\n            return;\n        }\n\n        if (this._sourceBuffersAreUpdating()) {\n            return;\n        }\n\n        console.log('Firing MediaSource.endOfStream()');\n        this._mediaSource.endOfStream();\n        this.fire('endofstream');\n    }\n\n    _handleSourceOpen() {\n        if (this._options.duration) {\n            this._mediaSource.duration = this._options.duration;\n            this.fire('durationset');\n        }\n\n        this._readyPromiseResolve();\n\n        this._mediaSource.removeEventListener('sourceopen', this.bound.handleSourceOpen);\n    }\n\n    _removeEventListeners() {\n        for (const type in this._buffersForCodec) {\n            this._buffersForCodec[type]._removeEventListeners();\n        }\n    }\n\n    _getCodecType(codec) {\n        return codec.indexOf('audio') === 0 ? 'audio' : 'video';\n    }\n}\n\nexport default MediaSorcerer;\n"],"names":["average","times","weights","length","total","i","weight","percentile","arr","p","sort","index","lower","Math","floor","upper","median","a","b","half","parseResponseHeaders","string","split","reduce","obj","header","colon","indexOf","key","substring","value","trim","toLowerCase","responseSpeeds","failedSegments","successfulSegments","progressSpeeds","progressSpeedMaxLogs","Fetcher","howMany","per","timesForPercentile","slice","timesForAverage","timesForMedian","time","Infinity","cutoff","getTime","speeds","progressObject","startTime","push","bitrate","speedIndex","performance","now","Date","n","pow","round","random","retryCount","parallel","includeWithSpeeds","_queue","_activeXhrRequests","Set","_retries","WeakMap","_retryCount","_running","_processingQueue","_parallel","_includeWithSpeeds","_pendingFetchMap","addEventListener","start","stop","abort","segment","callback","prepend","_addSegmentToQueue","_processQueue","stream","aborts","filter","data","forEach","_getIdentifierFromData","identifier","fire","xhr","currentPriority","priority","splice","hasOwnProperty","_insertAtPosition","numberToFetch","size","_fetchOne","get","set","_handleDownloadError","status","url","duration","backoff","calculateExponentialBackoff","info","add","_retry","getAllResponseHeaders","call","Uint8Array","response","id","byteRange","requestSendTime","shift","includeWithBandwidthChecks","XMLHttpRequest","lastBytesLoaded","lastTimeRecorded","req","lengthComputable","bitsLoaded","loaded","durationMS","durationSeconds","intervalObject","open","responseType","setRequestHeader","onload","e","delete","elapsedTimeInSeconds","target","byteLength","sizeInBits","bitsPerSecond","_handleXHRResponse","_continueProcessingQueue","onerror","onabort","send","num","pendingFetches","segmentDuration","Buffer","sorcerer","_sorcerer","_sourceBuffer","_activeStreamIndex","_needsStreamSwitch","_needInitSegment","_lastAppended","_toRemove","_streams","_quotaExceeded","_quotaExceededTimer","_appendingFinalSegment","_finalSegmentTime","undefined","_addingInitSegment","_isFirstSegment","_bufferState","on","_onDurationSet","bind","_process","_setActiveIndex","activeStreamIndex","indexHasChanged","shouldAbort","previousStreamIndex","previousStream","_switchToIndex","Promise","resolve","_resolveSwitchComplete","sourceBuffer","buffered","bufferStart","bufferEnd","end","isTimeInBuffer","clear","endTime","_mediaSource","reject","segments","bound","_handleUpdateEnd","handleUpdateEnd","handleEnded","_fireStreamHasEnded","removeEventListener","off","_frameDropper","streamIndex","activeStream","readyState","updating","self","setTimeout","remove","getInitSegment","then","buffer","appendBuffer","catch","err","error","toAppend","getNextSegment","getIdForSegment","isFinalSegment","isFinal","name","warn","removalThreshold","_video","currentTime","log","removeBuffer","_readyToAppend","unshift","_attachEvents","Stream","initSegment","codec","fetcher","_initSegment","_index","NaN","_codec","_fetcher","_bufferData","_segmentToId","_getInitSegmentPromise","isValidSegmentUrl","final","loadOnly","FrameDropper","video","_droppedFramesTimeout","_droppedFrameData","_decodedFrameData","_droppedFrames","_decodedFrames","_streamIndex","_startCheckingDroppedFrames","_stopCheckingDroppedFrames","_removeEvents","type","rates","ratesForAverage","_getTotalDroppedFrames","_getTotalFrames","startCheckingDroppedFrames","stopCheckingDroppedFrames","_checkDroppedFrames","totalDropped","droppedPerSecond","totalDecoded","_getTotalDecodedFrames","decodedPerSecond","getVideoPlaybackQuality","droppedVideoFrames","webkitDroppedFrameCount","totalVideoFrames","webkitDecodedFrameCount","quality","corruptedVideoFrames","MediaSorcerer","options","_options","ceil","_bufferCount","MediaSource","src","URL","createObjectURL","_buffersForCodec","_readyPromiseResolve","switchTo","getAverageSpeed","getMedianSpeed","getPercentileSpeed","getAverageBitrate","getResponseSpeeds","getFailedSegments","getSuccessfulSegments","getDroppedFrameRate","getDroppedFrameTotal","streamIndexAtTime","promises","all","codecType","_getCodecType","readyPromise","addSourceBuffer","code","appendWindowEnd","evt","addStream","_removeEventListeners","destroy","revokeObjectURL","_handleSourceOpen","handleSourceOpen","event","sourceBuffers","hasAppendedFinalSegment","_sourceBuffersAreUpdating","endOfStream","streams","audio"],"mappings":"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"}