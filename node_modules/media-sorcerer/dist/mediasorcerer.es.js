/*! media-sorcerer v3.1.6 | (c) 2017 Vimeo */
function average(times) {
    var weights = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    // Prevent deviding by zero
    if (times.length === 0) {
        return 0;
    }

    var total = 0;
    var length = 0;

    for (var i = 0; i < times.length; i++) {
        var weight = weights[i] || 1;
        length += weight;
        total += times[i] * weight;
    }

    return total / length;
}

// @see https://gist.github.com/IceCreamYou/6ffa1b18c4c8f6aeaad2
function percentile(arr, p) {
    arr.sort();

    if (arr.length === 0) {
        return 0;
    }

    if (p <= 0) {
        return arr[0];
    }

    if (p >= 1) {
        return arr[arr.length - 1];
    }

    var index = arr.length * p;
    var lower = Math.floor(index);
    var upper = lower + 1;
    var weight = index % 1;

    if (upper >= arr.length) {
        return arr[lower];
    }

    return arr[lower] * (1 - weight) + arr[upper] * weight;
}

function median(times) {
    times.sort(function (a, b) {
        return a - b;
    });

    var half = Math.floor(times.length / 2);

    if (times.length % 2) {
        return times[half];
    }

    return (times[half - 1] + times[half]) / 2.0;
}

function parseResponseHeaders(string) {
    if (!string) {
        return {};
    }

    return string.split('\n').reduce(function (obj, header) {
        var colon = header.indexOf(':');
        var key = header.substring(0, colon);
        var value = header.substring(colon + 1);

        if (typeof key !== 'undefined' && typeof value !== 'undefined') {
            obj[key.trim().toLowerCase()] = value.trim();
        }

        return obj;
    }, {});
}

function eventManager(obj) {
    obj = obj || {};
    var events = {};

    // Add a listener for an event
    obj.on = function(eventName, handler) {
        eventName = [].concat(eventName);

        for (var i = 0, length = eventName.length; i < length; i++) {
            var currentEvent = eventName[i];

            if (!currentEvent) {
                throw new Error('Tried to listen for an undefined event.');
            }

            if (!events[currentEvent]) {
                events[currentEvent] = [];
            }

            events[currentEvent].push(handler);
        }

        return obj;
    };

    // Add a listener for an event that will run one time only
    obj.once = function(eventName, handler) {
        function wrappedHandler() {
            handler.apply(obj.off(eventName, wrappedHandler), arguments);
        }

        // Store a reference to the original handler so we can remove it
        // if you call off with that handler.
        wrappedHandler.handler = handler;

        return obj.on(eventName, wrappedHandler);
    };

    // Remove a listener from an event
    obj.off = function(eventName, handler) {
        eventName = [].concat(eventName);

        for (var i = 0, length = eventName.length; i < length; i++) {
            var currentEvent = eventName[i];

            if (!currentEvent) {
                throw new Error('Tried to remove an undefined event.');
            }

            if (currentEvent in events) {
                var index = events[currentEvent].indexOf(handler);

                // Loop through all the handlers to find the wrapper so we can remove it
                // Not in there, return
                if (index === -1) {
                    for (var j = 0, jlength = events[currentEvent].length; j < jlength; j++) {
                        if (events[currentEvent][j].handler === handler) {
                            index = i;
                            break;
                        }
                    }

                    if (index === -1) {
                        return obj;
                    }
                }

                events[currentEvent].splice(index, 1);
            }
        }

        return obj;
    };

    // Fire an event
    obj.fire = function(eventName) {
        if (!eventName) {
            throw new Error('Tried to fire an undefined event.');
        }

        if (eventName in events) {

            // Make a copy so that we will definitely loop through all,
            // even if a handler is removed during the loop (by once, for example).
            var eventsCopy = events[eventName].slice(0);

            for (var i = 0, length = eventsCopy.length; i < length; i++) {
                eventsCopy[i].apply(obj, eventsCopy.slice.call(arguments, 1));
            }
        }

        return obj;
    };

    return obj;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var responseSpeeds = [];
var failedSegments = [];
var successfulSegments = [];

/**
 * progressSpeeds is an array containing historical bandwidth data.
 * The objects contained in the array are formatted as:
 *
 * {
 *   startTime: 'The starting timestamp of the request interval',
 *   length: 'The length in seconds of the request interval',
 *   bitrate: 'The bitrate we experienced during this interval'
 * }
*/
var progressSpeeds = [];

// The maximum amount of progress speed entries allowed within the `progressSpeeds` array.
var progressSpeedMaxLogs = 100;

var Fetcher = function () {
    createClass(Fetcher, null, [{
        key: 'getPercentileSpeed',


        /**
         * Returns the download speed over the last x number of requests
         *
         * @param  {Number} howMany number of requests to average over
         * @param  {Number} per     percentile value from 0 to 1
         * @return {Number}         speed in bps (bits per second)
         */
        value: function getPercentileSpeed() {
            var howMany = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
            var per = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.8;

            var timesForPercentile = responseSpeeds.slice(-howMany);
            return percentile(timesForPercentile, per);
        }
    }, {
        key: 'getAverageSpeed',
        value: function getAverageSpeed() {
            var howMany = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
            var weights = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            var timesForAverage = responseSpeeds.slice(-howMany);
            return average(timesForAverage, weights);
        }
    }, {
        key: 'getMedianSpeed',
        value: function getMedianSpeed() {
            var howMany = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;

            var timesForMedian = responseSpeeds.slice(-howMany);
            return median(timesForMedian);
        }
    }, {
        key: 'getResponseSpeeds',
        value: function getResponseSpeeds() {
            return responseSpeeds;
        }

        /**
         * Returns an array with the latest XHR progress download speeds.
         *
         * @return {Array} An array with `progressSpeedMaxLogs` progress speed logs
         */

    }, {
        key: 'getProgressSpeeds',
        value: function getProgressSpeeds() {
            return progressSpeeds;
        }

        /**
         * Returns the average bitrate experienced during the last X milliseconds
         *
         * @param  {Number} time - Time interval in milliseconds to look back on
         * @return {Number} The average segment download bitrate
         */

    }, {
        key: 'getAverageBitrate',
        value: function getAverageBitrate() {
            var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;

            var cutoff = Fetcher.getTime() - time;
            var speeds = [];
            var weights = [];

            for (var index = progressSpeeds.length - 1; index >= 0; index--) {
                var progressObject = progressSpeeds[index];

                if (progressObject.startTime < cutoff) {
                    break;
                }

                speeds.push(progressObject.bitrate);
            }

            for (var speedIndex = 0; speeds.length > speedIndex; speedIndex++) {
                weights.push(speeds.length - speedIndex);
            }

            return average(speeds, weights);
        }

        /**
         * Returns the failed segments array
         *
         * @return {Array}
         */

    }, {
        key: 'getFailedSegments',
        value: function getFailedSegments() {
            return failedSegments;
        }

        /**
         * Returns the successful segments array
         *
         * @return {Array}
         */

    }, {
        key: 'getSuccessfulSegments',
        value: function getSuccessfulSegments() {
            return successfulSegments;
        }
    }, {
        key: 'getTime',
        value: function getTime() {
            if (typeof performance !== 'undefined') {
                return performance.now();
            }

            return new Date().getTime();
        }

        // first retry 1.x seconds, 2nd retry 2.x and so on

    }, {
        key: 'calculateExponentialBackoff',
        value: function calculateExponentialBackoff(n) {
            return Math.pow(2, n) * 500 + Math.round(Math.random() * 1000);
        }

        /**
         * Fetcher constructor
         *
         * @param  {Number} [options.retryCount] - The maximum request rerty count
         * @param  {Number} [options.parallel] - The maximum amount of parallel downloads
         * @param  {Boolean} [options.includeWithSpeeds] - If downloads should be used in download speed calculations
         */

    }]);

    function Fetcher() {
        var _this = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$retryCount = _ref.retryCount,
            retryCount = _ref$retryCount === undefined ? 3 : _ref$retryCount,
            _ref$parallel = _ref.parallel,
            parallel = _ref$parallel === undefined ? 1 : _ref$parallel,
            _ref$includeWithSpeed = _ref.includeWithSpeeds,
            includeWithSpeeds = _ref$includeWithSpeed === undefined ? true : _ref$includeWithSpeed;

        classCallCheck(this, Fetcher);

        this._queue = [];
        this._activeXhrRequests = new Set();
        this._retries = new WeakMap();
        this._retryCount = retryCount;
        this._running = false;
        this._processingQueue = false;
        this._parallel = parallel;
        this._includeWithSpeeds = includeWithSpeeds;

        // This per-instance WeakMap will keep track of bytes downloaded
        // and is keyed off of activeXhrRequests
        this._pendingFetchMap = new WeakMap();

        eventManager(this);

        // These are necessary to prevent us from trying to download segments
        // when we are offline. Otherwise we will try to download them and fail
        // and retry a few times and then they will never be retried once we
        // come back online.
        //
        // @see https://github.vimeows.com/player/player/issues/1868
        window.addEventListener('online', function () {
            _this.start();
        });

        window.addEventListener('offline', function () {
            _this.stop();

            // If we don’t abort here then all fetches in progress will fail
            // when we come back online and the mediasource scanner won’t know
            // to try to download those segments again and those requests will
            // fail if the URLs have expired.
            _this.abort();
        });
    }

    createClass(Fetcher, [{
        key: 'add',


        ////////////////////
        // Public methods //
        ////////////////////

        value: function add(segment, callback, prepend) {
            this._addSegmentToQueue(segment, callback, prepend);
            if (this._running && !this._processingQueue) {
                this._processQueue();
            }

            return this;
        }
    }, {
        key: 'start',
        value: function start() {
            if (this._running) {
                return this;
            }

            this._running = true;
            this._processQueue();

            return this;
        }
    }, {
        key: 'stop',
        value: function stop() {
            this._running = false;

            return this;
        }

        /**
         * Aborts any queued requests and active requests for the passed stream
         * @param  {Stream} [stream]
         */

    }, {
        key: 'abort',
        value: function abort() {
            var _this2 = this;

            var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            // if stream is null aborts = this._queue
            var aborts = this._queue.filter(function (data) {
                return !stream || stream === data[0].stream;
            });

            aborts.forEach(function (data) {
                var _getIdentifierFromDat = _this2._getIdentifierFromData(data),
                    _getIdentifierFromDat2 = slicedToArray(_getIdentifierFromDat, 3),
                    identifier = _getIdentifierFromDat2[2];

                _this2.fire('downloadabort', identifier);
            });

            // if stream is null this._queue = []
            this._queue = this._queue.filter(function (data) {
                return stream && stream !== data[0].stream;
            });

            this._activeXhrRequests.forEach(function (xhr) {
                if (stream && stream !== xhr.stream) {
                    return;
                }
                xhr.abort();
            });
        }
        //////////////////////
        // Internal methods //
        //////////////////////

    }, {
        key: '_insertAtPosition',
        value: function _insertAtPosition(segment, callback) {
            // Find the position to insert this segment
            //
            // Note that the priority number here is actually backwards aka lower
            // number means it will end up earlier in the queue. So 0 means it will
            // be placed at the beginning.
            var i = 0;
            for (; i < this._queue.length; i++) {
                var currentPriority = this._queue[i][0].priority;
                if (currentPriority > segment.priority) {
                    break;
                }
            }

            this._queue.splice(i, 0, [segment, callback]);
        }
    }, {
        key: '_addSegmentToQueue',
        value: function _addSegmentToQueue(segment, callback, prepend) {
            // Prepend doesn't matter when using priority
            if (segment.hasOwnProperty('priority')) {
                this._insertAtPosition(segment, callback);
                return;
            }

            this._queue[prepend ? 'unshift' : 'push']([segment, callback]);
        }
    }, {
        key: '_processQueue',
        value: function _processQueue() {
            if (!this._running) {
                return;
            }

            this._processingQueue = true;
            var numberToFetch = this._parallel - this._activeXhrRequests.size;
            for (var i = 0; i < numberToFetch; i++) {
                this._fetchOne();
            }
        }
    }, {
        key: '_retry',
        value: function _retry(xhr, data, identifier) {
            var _this3 = this;

            var segment = data[0];
            var callback = data[1];

            if (!this._retries.get(segment)) {
                this._retries.set(segment, 0);
            }

            this._retries.set(segment, this._retries.get(segment) + 1);

            // Check if the maximum amount of retries have been attempted.
            if (this._retries.get(segment) > this._retryCount) {
                this._handleDownloadError(identifier, xhr.status, xhr.data.url, xhr.data.duration);
                return;
            }

            var backoff = Fetcher.calculateExponentialBackoff(this._retries.get(segment));

            console.info('Retrying', segment, 'after', backoff, 'ms');

            setTimeout(function () {
                var prepend = true;
                _this3.add(segment, callback, prepend);
            }, backoff);
        }

        /**
         * Manages completed XMLHttpRequest.
         *
         * @param {XMLHttpRequest} xhr
         * @param {Object} data
         * @param {Object} identifier
         * @param {Function} callback
         */

    }, {
        key: '_handleXHRResponse',
        value: function _handleXHRResponse(xhr, data, identifier, callback) {
            // For 5xx errors retry
            if (xhr.status >= 500 && xhr.status < 600) {
                this._retry(xhr, data, identifier);
                return;
            }

            // For 4xx errors trigger an error
            if (xhr.status >= 400 && xhr.status < 500) {
                this._handleDownloadError(identifier, xhr.status, xhr.data.url, xhr.data.duration);
                return;
            }

            this.fire('downloadend', identifier, {
                headers: parseResponseHeaders(xhr.getAllResponseHeaders())
            });
            successfulSegments.push({
                url: xhr.data.url,
                status: xhr.status,
                duration: xhr.data.duration
            });
            callback.call(this, new Uint8Array(xhr.response));
        }

        /**
         * Called when a segment download request has
         * returned a 404 status code.
         *
         * @param   {Object} identifier
         * @param   {Number} status
         * @param   {String} url
         * @param   {Number} duration
         */

    }, {
        key: '_handleDownloadError',
        value: function _handleDownloadError(identifier, status, url, duration) {
            failedSegments.push({
                url: url,
                status: status,
                duration: duration
            });
            this.fire('downloaderror', identifier, status);
        }
    }, {
        key: '_getIdentifierFromData',
        value: function _getIdentifierFromData(data) {
            // Data looks like:
            // [{
            //     url,
            //     byteRange,
            //     id
            // },
            // callback
            // ]
            var callback = data[1];
            var segment = data[0];
            var identifier = segment;

            if (segment.id) {
                identifier = segment.id;
            }

            return [segment.url, segment.byteRange, identifier, callback];
        }
    }, {
        key: '_continueProcessingQueue',
        value: function _continueProcessingQueue() {
            if (this._activeXhrRequests.size === 0 && this._queue.length === 0) {
                this._processingQueue = false;
                return;
            }

            if (this._activeXhrRequests.size < this._parallel) {
                this._processQueue();
            }
        }
    }, {
        key: '_fetchOne',
        value: function _fetchOne() {
            var _this4 = this;

            if (this._queue.length === 0) {
                this._processingQueue = false;
                return;
            }

            var requestSendTime = null;
            var data = this._queue.shift();

            var _getIdentifierFromDat3 = this._getIdentifierFromData(data),
                _getIdentifierFromDat4 = slicedToArray(_getIdentifierFromDat3, 4),
                url = _getIdentifierFromDat4[0],
                byteRange = _getIdentifierFromDat4[1],
                identifier = _getIdentifierFromDat4[2],
                callback = _getIdentifierFromDat4[3];

            var includeWithSpeeds = data[0].includeWithBandwidthChecks;
            var startTime = Fetcher.getTime();
            var xhr = new XMLHttpRequest();
            xhr.stream = data[0].stream;
            xhr.data = {};
            xhr.data.url = url;

            var lastBytesLoaded = 0;
            var lastTimeRecorded = Fetcher.getTime();

            // Cannot use initial progress interval since it counts latency
            var index = 0;

            xhr.addEventListener('progress', function (req) {
                if (req.lengthComputable) {
                    // Bits loaded since last progress
                    var bitsLoaded = (req.loaded - lastBytesLoaded) * 8;
                    var time = Fetcher.getTime();
                    var durationMS = time - lastTimeRecorded;
                    var durationSeconds = durationMS / 1000;
                    var bitrate = bitsLoaded / durationSeconds;

                    var intervalObject = {
                        startTime: lastTimeRecorded,
                        length: durationMS,
                        bitrate: bitrate,
                        index: index
                    };

                    if (index > 0) {
                        // Avoid appending too much to the progressSpeeds tracking array.
                        if (progressSpeeds.length >= progressSpeedMaxLogs) {
                            progressSpeeds.shift();
                        }

                        progressSpeeds.push(intervalObject);
                    }

                    lastTimeRecorded = time;
                    lastBytesLoaded = req.loaded;
                    index += 1;

                    _this4._pendingFetchMap.set(xhr, {
                        bytesTotal: req.total,
                        bytesLoaded: req.loaded,
                        percent: req.loaded / req.total,
                        identifier: identifier
                    });

                    _this4.fire('progress', identifier);
                }
            });

            xhr.open('GET', url, true);
            xhr.responseType = 'arraybuffer';

            if (byteRange) {
                xhr.setRequestHeader('Range', 'bytes=' + byteRange);
            }

            // Called when the XMLHttpRequest transaction completes successfully.
            xhr.onload = function (e) {
                var duration = Date.now() - requestSendTime;
                xhr.data.duration = duration;
                _this4._activeXhrRequests.delete(xhr);

                // If a segment is done being downloaded, clear limbo
                _this4._pendingFetchMap.delete(xhr);

                var elapsedTimeInSeconds = (Fetcher.getTime() - startTime) / 1000;

                // If the size is greater than 40kb then include it in the
                // response speeds.  This is cause for init segments the size
                // is smaller and a lot of the response time is network time so
                // the actual calculated bit rate is not useful.
                var size = e.target.response.byteLength;
                if (size > 40960) {
                    var sizeInBits = size * 8;
                    var bitsPerSecond = sizeInBits / elapsedTimeInSeconds;

                    // only keep last 100
                    if (responseSpeeds.length > 100) {
                        responseSpeeds.shift();
                    }

                    if (_this4._includeWithSpeeds && includeWithSpeeds) {
                        responseSpeeds.push(bitsPerSecond);
                    }
                }

                _this4._handleXHRResponse(xhr, data, identifier, callback);
                _this4._continueProcessingQueue();
            };

            // Fires when there is a failure on the network level.
            // If the error only exists on the application level,
            // e.g., an HTTP error code is sent, then onload still fires.
            xhr.onerror = function () {
                var duration = Date.now() - requestSendTime;
                xhr.data.duration = duration;
                _this4._activeXhrRequests.delete(xhr);
                _this4._pendingFetchMap.delete(xhr);
                _this4._retry(xhr, data, identifier);
                _this4._continueProcessingQueue();
            };

            // Called when an XMLHttpRequest transaction is aborted,
            // such as when the XMLHttpRequest.abort() function is called.
            xhr.onabort = function () {
                var duration = Date.now() - requestSendTime;
                xhr.data.duration = duration;
                failedSegments.push({
                    url: url,
                    status: 'abort',
                    duration: duration
                });
                // If a segment has been aborted, clear limbo
                _this4._pendingFetchMap.delete(xhr);

                _this4._activeXhrRequests.delete(xhr);

                _this4.fire('downloadabort', identifier);

                if (_this4._activeXhrRequests.size === 0 && _this4._queue.length === 0) {
                    _this4._processingQueue = false;
                }

                // This is because there might be objects in the queue
                // that belong to the non-aborted stream that we want to examine
                _this4._continueProcessingQueue();
            };

            this.fire('downloadstart', identifier);

            this._activeXhrRequests.add(xhr);
            requestSendTime = Date.now();
            xhr.send();
        }
    }, {
        key: 'parallel',
        get: function get() {
            return this._parallel;
        },
        set: function set(num) {
            this._parallel = num;
        }

        /**
         * Returns the downloaded bytes, total bytes and percent downloaded for
         * pending XHR requests.
         *
         * @return {Object} {[bytesTotal, bytesLoaded, percent]...}
         */

    }, {
        key: 'pendingFetches',
        get: function get() {
            var _this5 = this;

            var pendingFetches = [];
            this._activeXhrRequests.forEach(function (xhr) {
                if (_this5._pendingFetchMap.get(xhr)) {
                    pendingFetches.push(_this5._pendingFetchMap.get(xhr));
                }
            });

            return pendingFetches;
        }
    }]);
    return Fetcher;
}();

var segmentDuration = 6;

var Buffer = function () {

    /**
     * The Buffer object is a wrapper around the native SourceBuffer object.
     * It queries streams to get what segments to append to the buffer and handles switching between streams.
     *
     * @param  {MediaSorcerer} sorcerer
     */
    function Buffer(sorcerer) {
        classCallCheck(this, Buffer);

        eventManager(this);

        this._sorcerer = sorcerer;
        this._sourceBuffer = null;
        this._activeStreamIndex = null;
        this._needsStreamSwitch = false;
        this._needInitSegment = true;
        this._lastAppended = null;
        this._toRemove = [];
        this._streams = [];
        this._quotaExceeded = false;
        this._quotaExceededTimer = null;
        this._appendingFinalSegment = false;
        this._finalSegmentTime = undefined;
        this._addingInitSegment = false;
        this._isFirstSegment = true;
        this._bufferState = {};

        this._sorcerer.on('durationset', this._onDurationSet.bind(this));
    }

    createClass(Buffer, [{
        key: 'addStream',


        ////////////////////
        // Public methods //
        ////////////////////

        /**
         * Adds a stream object to this buffer.
         *
         * @param {Stream} stream A Stream object.
         */
        value: function addStream(stream) {
            var _this = this;

            stream.on('segmentadd', function () {
                return _this._process();
            });

            var index = this._streams.push(stream) - 1;
            stream.index = index;

            if (this._activeStreamIndex === null) {
                this._setActiveIndex(index);
                this._needsStreamSwitch = true;
            }
        }

        /**
         * Retrieves the index of the stream in the buffer at input time.
         *
         * @param {Number} time - The video time to retrieve buffer
         * @return {Number}
         */

    }, {
        key: 'streamIndexAtTime',
        value: function streamIndexAtTime(time) {
            // In Live, this is what the bufferState looks like
            // so we can get the active stream at the current time instead
            if (this._bufferState[undefined]) {
                return { stream: this.activeStreamIndex };
            }

            return this._bufferState[Math.floor(time / segmentDuration)];
        }

        /**
         * Switches the currently active stream to the specified stream or stream index.
         *
         * @param {Object} stream A Stream object or numeric index of which stream to switch to.
         * @param {Boolean} [abort] If the previous stream should be aborted.
         * @return {Promise} A Promise that will resolve when the first segment of the new stream has been appended to the buffer.
         */

    }, {
        key: 'switchTo',
        value: function switchTo(stream) {
            var _this2 = this;

            var abort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            var index = stream;
            if ((typeof stream === 'undefined' ? 'undefined' : _typeof(stream)) === 'object') {
                index = stream.index;
            }

            var indexHasChanged = this._activeStreamIndex !== index;
            var shouldAbort = indexHasChanged;

            // An index is set up by default when the first stream has been added
            // and that becomes the active index. This means if we later decide to
            // switch to that index we need to make sure to still fire the
            // streamswitch event before playback begins.
            if (!indexHasChanged && this._needsStreamSwitch) {
                indexHasChanged = true;
            }

            if (indexHasChanged) {
                // Assuming we have gotten here that means we don't need to force
                // another streamswitch event in the future
                this._needsStreamSwitch = false;

                var previousStreamIndex = this._activeStreamIndex;
                var previousStream = this._streams[previousStreamIndex];

                if (previousStream && shouldAbort && abort) {
                    previousStream.abort();
                }

                this._switchToIndex = index;
                this._setActiveIndex(index);
            }

            this._process();

            return new Promise(function (resolve) {
                if (!indexHasChanged) {
                    resolve();
                    return;
                }

                _this2._resolveSwitchComplete = function () {
                    if (_this2._switchToIndex !== index) {
                        return;
                    }

                    _this2._resolveSwitchComplete = null;
                    resolve();
                    _this2.fire('streamchange', index);
                };
            });
        }

        /**
         * Returns if the supplied time is within the source buffer.
         *
         * @param {Number} time - The time to lookup in seconds.
         * @return {Boolean}
         */

    }, {
        key: 'isTimeInBuffer',
        value: function isTimeInBuffer(time) {
            for (var i = 0; i < this.sourceBuffer.buffered.length; i++) {
                var bufferStart = this.sourceBuffer.buffered.start(i);
                var bufferEnd = this.sourceBuffer.buffered.end(i);

                if (bufferStart <= time && bufferEnd >= time) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Returns if the final segment has been appended for the purpose of firing
         * MediaSource.endOfStream().
         *
         * @return {Boolean}
         */

    }, {
        key: 'hasAppendedFinalSegment',
        value: function hasAppendedFinalSegment() {
            if (this._finalSegmentTime === undefined) {
                return false;
            }

            return this.isTimeInBuffer(this._finalSegmentTime);
        }

        /**
         * Clears out all segments in the queue for all streams
         * belonging to this buffer.
         */

    }, {
        key: 'clear',
        value: function clear() {
            this._streams.forEach(function (stream) {
                stream.clear();
            });
        }

        /**
         * Removes the allocated buffer between two playback times.
         *
         * @param  {Number} startTime The video time in seconds to start removal.
         * @param  {Number} [endTime] The video time in seconds to end removal.
         * @return {Promise}
         */

    }, {
        key: 'remove',
        value: function remove(startTime) {
            var _this3 = this;

            var endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._sorcerer._mediaSource.duration;

            return new Promise(function (resolve, reject) {
                _this3._toRemove.push([startTime, endTime, resolve]);
                _this3._process();
            });
        }

        /////////////////////
        // Private methods //
        /////////////////////

        /**
         * Initializes the buffer tracking object.
         */

    }, {
        key: '_onDurationSet',
        value: function _onDurationSet() {
            var duration = this._sorcerer._mediaSource.duration;
            var segments = Math.floor(duration / segmentDuration);
            segments += segmentDuration % duration > 1 ? 1 : 0;
            for (var i = 0; i < segments; i++) {
                this._bufferState[i] = {
                    stream: null,
                    segment: i,
                    type: 'video'
                };
            }
        }
    }, {
        key: '_attachEvents',
        value: function _attachEvents() {
            var _this4 = this;

            this.bound = {
                handleUpdateEnd: this._handleUpdateEnd.bind(this)
            };

            this._sourceBuffer.addEventListener('updateend', this.bound.handleUpdateEnd);
            this._sorcerer.on('endofstream', function () {
                _this4._handleUpdateEnd();
            });

            this._sorcerer.on('ended', this.bound.handleEnded);
        }
    }, {
        key: '_handleUpdateEnd',
        value: function _handleUpdateEnd(e) {
            if (this._appendingFinalSegment) {
                this._finalSegmentTime = this._sourceBuffer.buffered.end(this._sourceBuffer.buffered.length - 1);
                this._sorcerer._fireStreamHasEnded();
                this._appendingFinalSegment = false;
            }

            if (this._lastAppended) {
                this.fire('appendbufferend', this._lastAppended);
                this._lastAppended = null;

                if (this._resolveSwitchComplete) {
                    this._resolveSwitchComplete();
                }
            }
            this._process();
        }
    }, {
        key: '_removeEventListeners',
        value: function _removeEventListeners() {
            // It is possible for MediaSorcerer.destroy() to be called as a result
            // of failing to create sourceBuffers because the codec is not supported
            // by the browser. In that case a source buffer will never be added so
            // there won't be any bound events to actually remove since
            // _attachEvents was never actually called. This makes sure we have
            // bound events before trying to remove them.
            //
            // @see https://github.vimeows.com/player/player/issues/1744
            if (!this.bound) {
                return;
            }

            if (this._sourceBuffer) {
                this._sourceBuffer.removeEventListener('updateend', this.bound.handleUpdateEnd);
            }

            this._sorcerer.off('endofstream', this.bound.handleUpdateEnd);
            this._sorcerer.off('ended', this.bound.handleEnded);
        }
    }, {
        key: '_setActiveIndex',
        value: function _setActiveIndex(index) {
            // Anytime we switch streams, we need the init segment
            this._needInitSegment = true;
            this._activeStreamIndex = index;
            this._sorcerer._frameDropper.streamIndex = index;
        }

        /* eslint-disable complexity */

    }, {
        key: '_process',
        value: function _process() {
            var _this5 = this;

            var activeStream = this._streams[this._activeStreamIndex];

            if (!this._sourceBuffer) {
                this.on('sourcebufferattach', this._process);
                return;
            }

            if (!activeStream) {
                return;
            }

            // We can only append to the source buffer if the ready state is open
            // or ended, but not closed.
            //
            // The source will be reopened if it is in the ended state
            //
            // http://www.w3.org/TR/media-source/#widl-MediaSource-readyState
            // http://www.w3.org/TR/media-source/#sourcebuffer-prepare-append
            if (this._sorcerer._mediaSource.readyState === 'closed') {
                return;
            }

            var sourceBuffer = this._sourceBuffer;
            if (sourceBuffer.updating) {
                return;
            }

            if (this._toRemove.length) {
                var _toRemove$shift = this._toRemove.shift(),
                    _toRemove$shift2 = slicedToArray(_toRemove$shift, 3),
                    startTime = _toRemove$shift2[0],
                    endTime = _toRemove$shift2[1],
                    resolve = _toRemove$shift2[2];

                var self = this;
                sourceBuffer.addEventListener('updateend', function handleUpdateEnd(e) {
                    sourceBuffer.removeEventListener('updateend', handleUpdateEnd);
                    resolve();

                    clearTimeout(self._quotaExceededTimer);
                    self._quotaExceededTimer = setTimeout(function () {
                        self._quotaExceeded = false;
                        self._process();
                    }, 5000);
                });

                var start = startTime;
                sourceBuffer.remove(start, endTime);
                return;
            }

            // If we are part of a quotaExceeded removal then we should not do
            // anything
            if (this._quotaExceeded) {
                return;
            }

            // init segment should always be appended before other segments
            if (this._addingInitSegment) {
                return;
            }

            if (this._needInitSegment) {
                this._addingInitSegment = true;
                activeStream.getInitSegment().then(function (buffer) {
                    // ignore init segments for updateend events
                    _this5._lastAppended = null;
                    sourceBuffer.appendBuffer(buffer);
                    _this5._addingInitSegment = false;
                    return buffer;
                }).catch(function (err) {
                    console.error(err);
                    _this5._addingInitSegment = false;
                });
                this._needInitSegment = false;
                return;
            }

            var toAppend = activeStream.getNextSegment();
            // toAppend can be null when loading init segment and no other
            // segments have loaded yet
            if (toAppend === null) {
                return;
            }

            var identifier = activeStream.getIdForSegment(toAppend);
            var isFinalSegment = activeStream.isFinal(toAppend);

            if (isFinalSegment) {
                this._appendingFinalSegment = true;
            }

            this._lastAppended = identifier;
            this.fire('appendbufferstart', identifier);

            try {
                sourceBuffer.appendBuffer(toAppend);
                this._bufferState[identifier.segment] = identifier;

                if (this._isFirstSegment) {
                    this._isFirstSegment = false;
                    this.fire('initialbufferstart');
                }
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    this._quotaExceeded = true;
                    console.warn('QuotaExceededError');

                    // When you call remove on a SourceBuffer it has to be behind
                    // the currentTime by a certain amount otherwise you could run
                    // into issues where you end up removing the video in the buffer
                    // at the currentTime since the browser may remove up until the
                    // nearest keyframe to the endTime. Six seconds is an okay
                    // threshold for now.
                    var removalThreshold = 6;
                    if (this._sorcerer._video.currentTime > removalThreshold) {
                        var _startTime = 0;
                        var _endTime = this._sorcerer._video.currentTime - removalThreshold;
                        console.log('Removing buffer from ' + _startTime + ' to ' + _endTime + '\u2026');
                        this._sorcerer.removeBuffer(_startTime, _endTime);
                    }

                    activeStream._readyToAppend.unshift(toAppend);
                }
            }
        }
        /* eslint-enable complexity */

    }, {
        key: 'streams',
        get: function get() {
            return this._streams;
        }
    }, {
        key: 'activeStreamIndex',
        get: function get() {
            return this._activeStreamIndex;
        }
    }, {
        key: 'sourceBuffer',
        get: function get() {
            return this._sourceBuffer;
        },
        set: function set(sourceBuffer) {
            this._sourceBuffer = sourceBuffer;
            this._attachEvents();
            this.fire('sourcebufferattach');
        }
    }]);
    return Buffer;
}();

var Stream = function () {
    createClass(Stream, null, [{
        key: 'isValidSegmentUrl',


        // A string (url) or object (url + byteRange) is valid
        value: function isValidSegmentUrl(segment) {
            if (typeof segment === 'string') {
                return true;
            }

            if (typeof segment.url === 'string' && typeof segment.byteRange === 'string') {
                return true;
            }

            return false;
        }

        /**
         * The Stream object is a representation of a specific quality of audio or video.
         *
         * @param {UInt8Array|String|Object} initSegment A URL or ArrayBuffer representing the init segment for this stream.
         * @param {String} [codec] The codec string originally passed in when creating the stream with MediaSorcerer.addStream.
         * @param {Fetcher} [fetcher] A optional reference to a Fetcher instance.
         */

    }]);

    function Stream(initSegment) {
        var _this = this;

        var codec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var fetcher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Fetcher();
        classCallCheck(this, Stream);

        eventManager(this);

        this._readyToAppend = [];
        this._initSegment = null;
        this._index = NaN;
        this._codec = codec;
        this._fetcher = fetcher;
        this._fetcher.start();

        this._bufferData = new WeakMap();
        this._segmentToId = {};

        this._getInitSegmentPromise = new Promise(function (resolve, reject) {
            if (Stream.isValidSegmentUrl(initSegment)) {
                _this._fetcher.add({
                    url: initSegment.url || initSegment,
                    byteRange: initSegment.byteRange,
                    id: null,
                    stream: _this
                }, function (buffer) {
                    _this._initSegment = buffer;
                    resolve(buffer);
                });
                return;
            }

            _this._initSegment = initSegment;
            resolve(initSegment);
        });
    }

    createClass(Stream, [{
        key: 'getIdForSegment',
        value: function getIdForSegment(segment) {
            if (Stream.isValidSegmentUrl(segment)) {
                return this._segmentToId[segment];
            }

            return this._bufferData.get(segment).id;
        }
    }, {
        key: 'isFinal',
        value: function isFinal(segment) {
            return this._bufferData.get(segment).final;
        }

        /**
         * Adds a segment to a stream.
         *
         * @param {UInt8Array|String|Object} segment - Actual buffer data (initSegment), segment url, or {url, byteRange}
         * @param {Object} [options.identifier] - The stream indentifier object
         * @param {Boolean} [options.isFinalSegment] - Whether or not this is the final segment
         * @param {Boolean} [options.loadOnly] - If the segment should be preloaded
         * @param {Number} [options.priority] - The segment priority. lower number means it will end up earlier in
         *                                     the queue. So 0 means it will be placed at the beginning.
         * @param {Boolean} [options.includeWithBandwidthChecks] - If this download of this segment should be included in
         *                                                        bandwidth checks.
         * @return {Void}
         */

    }, {
        key: 'addSegment',
        value: function addSegment(segment) {
            var _this2 = this;

            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                _ref$identifier = _ref.identifier,
                identifier = _ref$identifier === undefined ? null : _ref$identifier,
                _ref$isFinalSegment = _ref.isFinalSegment,
                isFinalSegment = _ref$isFinalSegment === undefined ? false : _ref$isFinalSegment,
                _ref$loadOnly = _ref.loadOnly,
                loadOnly = _ref$loadOnly === undefined ? false : _ref$loadOnly,
                _ref$priority = _ref.priority,
                priority = _ref$priority === undefined ? 0 : _ref$priority,
                _ref$includeWithBandw = _ref.includeWithBandwidthChecks,
                includeWithBandwidthChecks = _ref$includeWithBandw === undefined ? true : _ref$includeWithBandw;

            return new Promise(function (resolve, reject) {
                if (Stream.isValidSegmentUrl(segment)) {
                    _this2._segmentToId[segment] = identifier || segment;

                    _this2.fire('queued', _this2.getIdForSegment(segment));

                    _this2._fetcher.add({
                        url: segment.url || segment,
                        byteRange: segment.byteRange,
                        id: _this2.getIdForSegment(segment),
                        stream: _this2,
                        includeWithBandwidthChecks: includeWithBandwidthChecks,
                        priority: priority
                    }, function (buffer) {
                        _this2._bufferData.set(buffer, {
                            id: identifier || segment,
                            final: isFinalSegment
                        });

                        _this2._readyToAppend.push(buffer);

                        _this2.fire('bufferqueueadd', _this2.getIdForSegment(segment));

                        if (!loadOnly) {
                            _this2.fire('segmentadd');
                        }

                        resolve();
                    });

                    return;
                }

                _this2._bufferData.set(segment, {
                    id: identifier,
                    final: isFinalSegment
                });

                _this2._readyToAppend.push(segment);
                _this2.fire('bufferqueueadd', identifier);

                resolve();
            });
        }
    }, {
        key: 'clear',
        value: function clear() {
            this._readyToAppend = [];
        }
    }, {
        key: 'abort',
        value: function abort() {
            var _this3 = this;

            // This has to wait on the init segment to be ready because otherwise
            // if abort is called while the init segment is downloaded it will abort
            // the init segment request.
            this._getInitSegmentPromise.then(function () {
                _this3._fetcher.abort(_this3);
                return;
            }).catch(function (error) {
                console.error(error);
            });
        }
    }, {
        key: 'getNextSegment',
        value: function getNextSegment() {
            if (this._readyToAppend.length === 0) {
                return null;
            }

            return this._readyToAppend.shift();
        }
    }, {
        key: 'getInitSegment',
        value: function getInitSegment() {
            return this._getInitSegmentPromise;
        }
    }, {
        key: 'codec',
        get: function get() {
            return this._codec;
        },
        set: function set(value) {
            this._codec = value;
        }
    }, {
        key: 'index',
        get: function get() {
            return this._index;
        },
        set: function set(value) {
            this._index = value;
        }
    }, {
        key: 'pendingFetches',
        get: function get() {
            return this._fetcher.pendingFetches;
        }
    }]);
    return Stream;
}();

/**
 * @fileoverview Manager class that checks a video for dropped frames
 */

var FrameDropper = function () {
    function FrameDropper(video) {
        classCallCheck(this, FrameDropper);

        this._video = video;
        this._running = false;
        this._droppedFramesTimeout = null;

        this._droppedFrameData = {};
        this._decodedFrameData = {};
        this._droppedFrames = 0;
        this._decodedFrames = 0;

        // Key to collect dropped frames on
        // Might be worth it to not let an instance of this class start
        // without explicitly setting the key
        this._streamIndex = 'default';

        this.bound = {
            startCheckingDroppedFrames: this._startCheckingDroppedFrames.bind(this),
            stopCheckingDroppedFrames: this._stopCheckingDroppedFrames.bind(this)
        };
    }

    createClass(FrameDropper, [{
        key: 'start',


        ////////////////////
        // Public methods //
        ////////////////////

        value: function start() {
            this._startCheckingDroppedFrames();
            return this;
        }
    }, {
        key: 'stop',
        value: function stop() {
            this._stopCheckingDroppedFrames();
            return this;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this._stopCheckingDroppedFrames();
            this._removeEvents();
        }

        /**
         * Get sample of dropped frames on a specific key index
         *
         * @param  {Number} howMany Amount of items to sample
         * @param  {Mixed} streamIndex      key identifier to get sampled frames from
         * @param  {String} type    type of sampling, ie median or average
         * @return {Number}         Calculated amount of dropped frames
         */

    }, {
        key: 'getDroppedFrameRate',
        value: function getDroppedFrameRate(howMany, streamIndex) {
            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'average';

            var rates = this._droppedFrameData[streamIndex];

            if (!rates) {
                return 0;
            }

            if (rates.length < howMany) {
                return 0;
            }

            var ratesForAverage = rates.slice(-howMany);
            if (type === 'median') {
                return median(ratesForAverage);
            }

            return average(ratesForAverage);
        }
    }, {
        key: 'getDroppedFrameTotal',
        value: function getDroppedFrameTotal() {
            return {
                dropped: this._getTotalDroppedFrames(),
                total: this._getTotalFrames()
            };
        }

        /////////////////////
        // Private methods //
        /////////////////////

    }, {
        key: '_attachEvents',
        value: function _attachEvents() {
            this._video.addEventListener('playing', this.bound.startCheckingDroppedFrames);
            this._video.addEventListener('pause', this.bound.stopCheckingDroppedFrames);
            this._video.addEventListener('ended', this.bound.stopCheckingDroppedFrames);
        }
    }, {
        key: '_removeEvents',
        value: function _removeEvents() {
            this._video.removeEventListener('playing', this.bound.startCheckingDroppedFrames);
            this._video.removeEventListener('pause', this.bound.stopCheckingDroppedFrames);
            this._video.removeEventListener('ended', this.bound.stopCheckingDroppedFrames);
        }
    }, {
        key: '_startCheckingDroppedFrames',
        value: function _startCheckingDroppedFrames() {
            this._running = true;
            this._checkDroppedFrames();
        }
    }, {
        key: '_stopCheckingDroppedFrames',
        value: function _stopCheckingDroppedFrames() {
            this._running = false;
        }
    }, {
        key: '_checkDroppedFrames',
        value: function _checkDroppedFrames() {
            var _this = this;

            if (!this._running || this._streamIndex === null) {
                return;
            }

            clearTimeout(this._droppedFramesTimeout);

            var totalDropped = this._getTotalDroppedFrames();
            var droppedPerSecond = totalDropped - this._droppedFrames;

            this._droppedFrames = totalDropped;

            var totalDecoded = this._getTotalDecodedFrames();
            var decodedPerSecond = totalDecoded - this._decodedFrames;
            this._decodedFrames = totalDecoded;

            if (!this._droppedFrameData[this._streamIndex]) {
                this._droppedFrameData[this._streamIndex] = [];
            }

            if (!this._decodedFrameData[this._streamIndex]) {
                this._decodedFrameData[this._streamIndex] = [];
            }

            if (this._droppedFrameData[this._streamIndex].length > 100) {
                this._droppedFrameData[this._streamIndex].shift();
            }

            if (this._decodedFrameData[this._streamIndex].length > 100) {
                this._decodedFrameData[this._streamIndex].shift();
            }

            this._droppedFrameData[this._streamIndex].push(droppedPerSecond);
            this._decodedFrameData[this._streamIndex].push(decodedPerSecond);

            this._droppedFramesTimeout = setTimeout(function () {
                _this._checkDroppedFrames();
            }, 1000);
        }
    }, {
        key: '_getTotalDroppedFrames',
        value: function _getTotalDroppedFrames() {
            if (typeof this._video.getVideoPlaybackQuality === 'function') {
                return this._video.getVideoPlaybackQuality().droppedVideoFrames;
            }

            return this._video.webkitDroppedFrameCount || 0;
        }
    }, {
        key: '_getTotalFrames',
        value: function _getTotalFrames() {
            if (typeof this._video.getVideoPlaybackQuality === 'function') {
                return this._video.getVideoPlaybackQuality().totalVideoFrames;
            }

            return this._video.webkitDecodedFrameCount || 0;
        }
    }, {
        key: '_getTotalDecodedFrames',
        value: function _getTotalDecodedFrames() {
            if (typeof this._video.getVideoPlaybackQuality === 'function') {
                var quality = this._video.getVideoPlaybackQuality();
                return quality.totalVideoFrames - quality.droppedVideoFrames - quality.corruptedVideoFrames;
            }

            return this._video.webkitDecodedFrameCount || 0;
        }
    }, {
        key: 'streamIndex',
        get: function get() {
            return this._streamIndex;
        },
        set: function set(value) {
            this._streamIndex = value;
        }
    }]);
    return FrameDropper;
}();

var MediaSorcerer = function () {

    /**
     * Creates a new MediaSorcerer object.
     *
     * @param  {HTMLElement} video A reference to the video tag element on the page that you want to use MediaSource with.
     * @param  {Object} [options] Options for MediaSorcerer. Currently the only supported option is the video duration.
     */
    function MediaSorcerer(video) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, MediaSorcerer);

        this._video = video;
        this._options = options;

        eventManager(this);

        // In Chrome there is an issue with floats where the duration may show
        // up as 186.773333333 and the currentTime at the end shows up as
        // 186.773333.
        //
        // There are also cases where the duration might be 16.766 and the
        // currentTime comes back as 16.765999
        //
        // In order to work around this we need to change the duration passed to
        // the media source object.
        //
        // Why we need to ceil this to the nearest hundred is beyond me.
        // Somehow by changing it, it causes Chrome to correctly map the
        // video.currentTime to the video.duration. Otherwise there are floating
        // point rounding errors.
        if (this._options.duration) {
            this._options.duration = Math.ceil(this._options.duration * 100) / 100;
        }

        this._bufferCount = 0;
        this._frameDropper = new FrameDropper(video);
        this._mediaSource = new MediaSource();
        this._fetcher = new Fetcher({ parallel: 1 });
        this._video.src = URL.createObjectURL(this._mediaSource);
        this._buffersForCodec = {};
        this._readyPromiseResolve = null;

        this._attachEvents();
    }

    /**
     * A reference to the actual MediaSource object being used for playback.
     *
     * @return {MediaSource}
     */


    createClass(MediaSorcerer, [{
        key: 'switchTo',


        ////////////////////
        // Public methods //
        ////////////////////

        /**
         * A shortcut for calling Buffer.switchTo when there is only a single (video) buffer
         *
         * @param  {Object} stream
         * @return {Boolean|Promise}
         */
        value: function switchTo(stream) {
            if (this._bufferCount === 1) {
                return this.video.switchTo(stream);
            }

            console.error('The switch method on MediaSorcerer only works with single streams');
            return false;
        }

        /**
         * Gets the current download speed for the viewer in bps (bits per second).
         *
         * Available Options
         *   type {String} The way to calculate the speed (“average”, “median”, or “percentile”).
         *   howMany {Number} The number of recent speeds to include when doing the calculation.
         *   weights {Array} An array of weights to use to calculate a weighted average.
         *   percentile {Number} The percentile to use from 0 to 1 if you want a percentile speed.
         *
         * @param {Object} options An object containing options
         * @return {Number}
         */

    }, {
        key: 'getCurrentSpeed',
        value: function getCurrentSpeed() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref$type = _ref.type,
                type = _ref$type === undefined ? 'average' : _ref$type,
                _ref$howMany = _ref.howMany,
                howMany = _ref$howMany === undefined ? 10 : _ref$howMany,
                _ref$weights = _ref.weights,
                weights = _ref$weights === undefined ? [] : _ref$weights,
                _ref$percentile = _ref.percentile,
                percentile = _ref$percentile === undefined ? null : _ref$percentile;

            if (type === 'average') {
                return Fetcher.getAverageSpeed(howMany, weights);
            }

            if (type === 'median') {
                return Fetcher.getMedianSpeed(howMany);
            }

            return Fetcher.getPercentileSpeed(howMany, percentile);
        }

        /**
         * Returns the average segment download bitrate.
         *
         * @param  {Number} [time] - Time interval in milliseconds to look back on
         * @return {Number} The average segment download bitrate
         */

    }, {
        key: 'getAverageDownloadBitrate',
        value: function getAverageDownloadBitrate() {
            var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;

            return Fetcher.getAverageBitrate(time);
        }

        /**
         * Returns an array of (up to) the last 100 raw response speeds (in bits per second)
         * in case you want to use them in a way that getCurrentSpeed will provide.
         *
         * @return {Array}
         */

    }, {
        key: 'getResponseSpeeds',
        value: function getResponseSpeeds() {
            return Fetcher.getResponseSpeeds();
        }

        /**
         * Returns the failed segments array
         *
         * @return {Array}
         */

    }, {
        key: 'getFailedSegments',
        value: function getFailedSegments() {
            return Fetcher.getFailedSegments();
        }

        /**
         * Returns the successful segments array
         *
         * @return {Array}
         */

    }, {
        key: 'getSuccessfulSegments',
        value: function getSuccessfulSegments() {
            return Fetcher.getSuccessfulSegments();
        }

        /**
         * Returns the rate of dropped frames over the last x number of seconds.
         *
         * @param  {Number} howMany Number of seconds to look at.
         * @param  {Number} [streamIndex] Which stream to check.
         * @param  {String} [type] How to calculate the number of dropped frames (“average”, or “median”).
         * @return {Number}
         */

    }, {
        key: 'getDroppedFrameRate',
        value: function getDroppedFrameRate(howMany) {
            var streamIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.activeStreamIndex;
            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'average';

            return this._frameDropper.getDroppedFrameRate(howMany, streamIndex, type);
        }

        /**
         * Returns the total number of dropped frames throughout the entire playback session.
         *
         * @return {Number}
         */

    }, {
        key: 'getDroppedFrameTotal',
        value: function getDroppedFrameTotal() {
            return this._frameDropper.getDroppedFrameTotal();
        }

        /**
         * Clears out all buffers that are currently in the queue to be
         * appended across all buffers and streams.
         */

    }, {
        key: 'clear',
        value: function clear() {
            for (var type in this._buffersForCodec) {
                this._buffersForCodec[type].clear();
            }
        }

        /**
         * Returns a stream object from a given video time.
         *
         * @param  {Number} time - The video time to lookup
         * @param  {String} type - The type of stream to reference ('audio' or 'video')
         * @return {Object}
         */

    }, {
        key: 'streamIndexAtTime',
        value: function streamIndexAtTime(time, type) {
            if (!this._buffersForCodec[type].streamIndexAtTime(time)) {
                return null;
            }

            return this._buffersForCodec[type].streamIndexAtTime(time).stream;
        }

        /**
         * Calls Buffer.remove on each Buffer object that has been created.
         *
         * @param  {Number} [startTime]
         * @param  {Number} [endTime]
         * @return {Promise}
         */

    }, {
        key: 'removeBuffer',
        value: function removeBuffer() {
            var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._video.duration;

            if (startTime > endTime) {
                return Promise.resolve();
            }

            var promises = [];
            for (var type in this._buffersForCodec) {
                promises.push(this._buffersForCodec[type].remove(startTime, endTime));
            }

            return Promise.all(promises);
        }

        /**
         * Creates a new Stream object and adds it to the corresponding Buffer object.
         *
         * @param {String} codec The codec string corresponding to the stream you are creating.
         * @param {String} initSegment A URL or ArrayBuffer object representing the init segment for this stream.
         * @return {Object} The newly created stream object.
         */

    }, {
        key: 'addStream',
        value: function addStream(codec, initSegment) {
            var _this = this;

            var codecType = this._getCodecType(codec);
            if (!this._buffersForCodec[codecType]) {
                this._bufferCount += 1;
                var buffer = new Buffer(this, codecType);
                this._buffersForCodec[codecType] = buffer;

                this.readyPromise.then(function () {
                    var sourceBuffer = void 0;
                    try {
                        sourceBuffer = _this._mediaSource.addSourceBuffer(codec);
                    } catch (e) {

                        // if we have hit the maximum number then return the last
                        // used video source buffer
                        if (e.code === 22) {
                            sourceBuffer = _this._buffersForCodec[codecType];
                        } else {
                            console.error(e);
                            _this.fire('srcnotsupported', e);
                            return;
                        }
                    }

                    // This prevents a segment from being able to be added beyond a
                    // certian time.
                    if (_this._options.duration) {
                        sourceBuffer.appendWindowEnd = _this._options.duration;
                    }

                    buffer.sourceBuffer = sourceBuffer;

                    return;
                }).catch(function (error) {
                    console.error(error);
                });

                ['appendbufferstart', 'appendbufferend', 'streamchange', 'initialbufferstart'].forEach(function (evt) {
                    buffer.on(evt, function (identifier) {
                        _this.fire(evt, identifier);
                    });
                });
            }

            var stream = new Stream(initSegment, codec, this._fetcher);

            // Might not need 'queued' event soon since addSegment has been
            // promisified.
            ['queued', 'bufferqueueadd'].forEach(function (evt) {
                stream.on(evt, function (identifier) {
                    _this.fire(evt, identifier);
                });
            });

            this._buffersForCodec[codecType].addStream(stream);

            return stream;
        }

        /**
         * Destroys the MediaSorcerer instance and removes all event listeners.
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.clear();
            this._removeEventListeners();

            this._frameDropper.destroy();
            this._fetcher.abort();

            if (this._video.src) {
                URL.revokeObjectURL(this._video.src);
            }
        }

        /////////////////////
        // Private methods //
        /////////////////////

    }, {
        key: '_attachEvents',
        value: function _attachEvents() {
            var _this2 = this;

            this.bound = {
                handleSourceOpen: this._handleSourceOpen.bind(this)
            };

            this.readyPromise = new Promise(function (resolve, reject) {
                _this2._readyPromiseResolve = resolve;
                _this2._mediaSource.addEventListener('sourceopen', _this2.bound.handleSourceOpen);
            });

            ['downloadstart', 'downloadend', 'downloadabort', 'downloaderror', 'progress'].forEach(function (event) {
                _this2._fetcher.on(event, function () {
                    for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
                        data[_key] = arguments[_key];
                    }

                    _this2.fire.apply(_this2, [event].concat(data));
                });
            });
        }
    }, {
        key: '_sourceBuffersAreUpdating',
        value: function _sourceBuffersAreUpdating() {
            for (var i = 0; i < this._mediaSource.sourceBuffers.length; i++) {
                if (this._mediaSource.sourceBuffers[i].updating) {
                    return true;
                }
            }

            return false;
        }
    }, {
        key: '_fireStreamHasEnded',
        value: function _fireStreamHasEnded() {
            for (var type in this._buffersForCodec) {
                var buffer = this._buffersForCodec[type];
                if (!buffer.hasAppendedFinalSegment()) {
                    return;
                }
            }

            // If the ready state is not open or there are source buffers updating
            // we cannot call endOfStream
            //
            // @see http://www.w3.org/TR/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error
            if (this._mediaSource.readyState !== 'open') {
                return;
            }

            if (this._sourceBuffersAreUpdating()) {
                return;
            }

            console.log('Firing MediaSource.endOfStream()');
            this._mediaSource.endOfStream();
            this.fire('endofstream');
        }
    }, {
        key: '_handleSourceOpen',
        value: function _handleSourceOpen() {
            if (this._options.duration) {
                this._mediaSource.duration = this._options.duration;
                this.fire('durationset');
            }

            this._readyPromiseResolve();

            this._mediaSource.removeEventListener('sourceopen', this.bound.handleSourceOpen);
        }
    }, {
        key: '_removeEventListeners',
        value: function _removeEventListeners() {
            for (var type in this._buffersForCodec) {
                this._buffersForCodec[type]._removeEventListeners();
            }
        }
    }, {
        key: '_getCodecType',
        value: function _getCodecType(codec) {
            return codec.indexOf('audio') === 0 ? 'audio' : 'video';
        }
    }, {
        key: 'mediaSource',
        get: function get() {
            return this._mediaSource;
        }

        /**
         * A shortcut for accessing Stream objects when there is a single (video) buffer.
         *
         * @return {Array|Buffer}
         */

    }, {
        key: 'streams',
        get: function get() {
            if (this._bufferCount === 1) {
                return this.video.streams;
            }

            console.error('The streams property on MediaSorcerer only works with single streams');
            return false;
        }

        /**
         * A shortcut for accessing the currently active stream index when there is a single (video) buffer.
         *
         * @return {Number|Boolean}
         */

    }, {
        key: 'activeStreamIndex',
        get: function get() {
            if (this._bufferCount === 1) {
                return this.video.activeStreamIndex;
            }

            console.error('The activeStreamIndex property on MediaSorcerer only works with single streams');
            return false;
        }

        /**
         * A reference to the video buffer object or false if there is no video buffer.
         *
         * @return {Buffer|Boolan}
         */

    }, {
        key: 'video',
        get: function get() {
            if (this._buffersForCodec.video) {
                return this._buffersForCodec.video;
            }

            console.error('No video streams have been added to MediaSorcerer');
            return false;
        }

        /**
         * A reference to the audio buffer object or false if there is no audio buffer.
         *
         * @return {Buffer|Boolean}
         */

    }, {
        key: 'audio',
        get: function get() {
            if (this._buffersForCodec.audio) {
                return this._buffersForCodec.audio;
            }

            console.error('No audio streams have been added to MediaSorcerer');
            return false;
        }
    }]);
    return MediaSorcerer;
}();

export default MediaSorcerer;
//# sourceMappingURL=mediasorcerer.es.js.map
